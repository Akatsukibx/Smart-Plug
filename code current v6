/* Smart Plug – Stable current v3.8.3
   - AutoBaseBoot: เซ็ต base จาก raw อัตโนมัติเมื่อบูตแล้วค่าต่ำ
   - Fast on-relay idle capture (เรียน base เร็วขึ้น)
   - raw-idle gate + unclamp คงเดิม
   - bi-AutoK + simultaneous solve คงเดิม
*/
#include "thingProperties.h"
#include <Arduino.h>
#include <math.h>

/*** Pins / Board ***/
#ifndef SWAP_AB
#define SWAP_AB 0
#endif
#define PIN_A2 A3
#define PIN_A3 A2
#if SWAP_AB
  #define ADC_I_A PIN_A3
  #define ADC_I_B PIN_A2
#else
  #define ADC_I_A PIN_A2
  #define ADC_I_B PIN_A3
#endif
#define ADC_I_ALL A6

#ifndef D2
#define D2 2
#endif
#ifndef D5
#define D5 5
#endif
#define RELAY_A_PIN D2
#define RELAY_B_PIN D5
const bool RELAY_ACTIVE_LOW=false;

/*** Options ***/
#define RELAY_GATING true
enum AllMode{ MODE_SUM=0, MODE_CT=1 }; AllMode allMode=MODE_SUM;

/*** ADC & scales ***/
static const float ADC_REF=3.30f; static const int ADC_MAX=4095;
#define ACS712_V_PER_A 0.024f
static const float V_PER_A_A   = ACS712_V_PER_A;
static const float V_PER_A_B   = ACS712_V_PER_A;
static const float V_PER_A_ALL = 0.033f;

/*** Filters & thresholds ***/
static const float EMA_ALPHA_OUT=0.25f, HPF_ALPHA=0.01f;
static const float DZ_A=0.010f, DZ_B=0.012f, DZ_CT=0.020f;
static const float DZ_AFTER_COMP=0.018f;
#define NO_LOAD_THRESHOLD 0.012f

// adaptive raw-idle margin (raw < base + margin → idle)
#define RAW_IDLE_MARGIN_A 0.030f
#define RAW_IDLE_MARGIN_B 0.030f

// side-idle clamp uses IA/IB after comp
#define SIDE_IDLE_I     0.045f
#define OTHER_ACTIVE_I  0.18f
#define SIDE_IDLE_HOLD  1500

// activity hysteresis
#define ACTIVATE_I       0.08f
#define RELEASE_I        0.05f
#define ACTIVATE_COUNT   4
#define RELEASE_COUNT    6
#define ACTIVE_HOLD_MS   4000

// fast unclamp
#define RISE_TRIG_I       0.10f
#define RISE_FRAMES       2
#define RAW_RISE_TRIG_A   0.025f
#define RAW_RISE_TRIG_B   0.020f
#define RAW_RISE_FRAMES   2
#define UNCLAMP_HOLD_MS   2500

// on-relay idle capture (เรียน base แม้ ON)
#define CAPTURE_MARGIN_A   0.035f
#define CAPTURE_MARGIN_B   0.035f
#define CAPTURE_HOLD_MS    600       // เร็วขึ้นจาก 1200
#define CAPTURE_ALPHA      0.60f     // ดัน base เข้าหา raw ไวขึ้น

/*** Helpers ***/
static inline float adcToVolt(int a){ return (a*ADC_REF)/(float)ADC_MAX; }
static inline float ema(float p,float x,float a){ return a*x + (1.0f-a)*p; }
static inline float deadzone(float x,float dz){ return (fabsf(x)<dz)?0.0f:x; }
static inline float round2(float x){ return roundf(x*100.0f)/100.0f; }
static inline float floorToZero(float x,float eps=2e-3f){ return (fabsf(x)<eps)?0.0f:x; }

/*** HPF offsets ***/
float offA=ADC_REF/2, offB=ADC_REF/2, offAll=ADC_REF/2;

/*** Irms HPF ***/
static float readIrmsHPF(int pin,float &off,float v_per_A){
  const uint32_t T=120, t0=millis(); double s=0; uint32_t n=0;
  while(millis()-t0<T){
    float v=adcToVolt(analogRead(pin));
    off=ema(off,v,HPF_ALPHA);
    float ac=v-off; s += (double)ac*ac; n++; yield();
  }
  if(!n) return 0.0f;
  float Vrms=sqrt(s/(double)n);
  return Vrms/v_per_A;
}

/*** Cal/Zero & bases ***/
float calA=1.0f, calB=1.0f;
float baseA=0.0f, baseB=0.0f;

static void doZero(){
  double sA=0,sB=0; int n=0; uint32_t t0=millis();
  while(millis()-t0<1200){
    sA+=readIrmsHPF(ADC_I_A,offA,V_PER_A_A)*calA;
    sB+=readIrmsHPF(ADC_I_B,offB,V_PER_A_B)*calB;
    n++; delay(5);
  }
  baseA=constrain((float)(sA/(n?n:1)),0.0f,0.5f);
  baseB=constrain((float)(sB/(n?n:1)),0.0f,0.5f);
  Serial.printf("[Zero] baseA=%.3f baseB=%.3f\n",baseA,baseB);
}

/*** Cross learn (เดิม) ***/
bool  compEnabled=true;
float K_BA=0.40f, K_AB=0.40f;
const float K_ALPHA=0.30f;
static uint32_t kLogMs=0;
static void learnK_BA(float iA,float iB,float A_raw,float B_raw){
  if(relayA && (B_raw<baseB+RAW_IDLE_MARGIN_B) && (iB<0.03f) && iA>0.10f){
    float r=(iA>0.001f)?(iB/iA):0.0f; r=constrain(r,0.0f,0.90f);
    K_BA=ema(K_BA,r,K_ALPHA);
    if(!kLogMs || millis()-kLogMs>3000){ Serial.printf("[AutoK_BA] K_BA=%.3f\n",K_BA); kLogMs=millis(); }
  }
}
static void learnK_AB(float iA,float iB,float A_raw,float B_raw){
  if(relayB && (A_raw<baseA+RAW_IDLE_MARGIN_A) && (iA<0.03f) && iB>0.10f){
    float r=(iB>0.001f)?(iA/iB):0.0f; r=constrain(r,0.0f,0.90f);
    K_AB=ema(K_AB,r,K_ALPHA);
    if(!kLogMs || millis()-kLogMs>3000){ Serial.printf("[AutoK_AB] K_AB=%.3f\n",K_AB); kLogMs=millis(); }
  }
}

/*** States ***/
uint32_t bothIdleTs=0;
int actCntA=0, relCntA=0, actCntB=0, relCntB=0;
bool activeA=false, activeB=false;
uint32_t activeUntilA=0, activeUntilB=0;

// fast-unclamp + drip/idle-capture timers
int riseCntA=0, riseCntB=0, rawRiseCntA=0, rawRiseCntB=0;
uint32_t unclampUntilA=0, unclampUntilB=0;
uint32_t onIdleSinceA=0, onIdleSinceB=0;
uint32_t capSinceA=0, capSinceB=0;

/*** Outputs ***/
float iA_o=0.0f, iB_o=0.0f, iAll_o=0.0f;

void setup(){
  Serial.begin(115200); delay(300);
  pinMode(RELAY_A_PIN,OUTPUT); pinMode(RELAY_B_PIN,OUTPUT);
  bool offLevel=RELAY_ACTIVE_LOW?HIGH:LOW;
  digitalWrite(RELAY_A_PIN,offLevel); digitalWrite(RELAY_B_PIN,offLevel);

  analogReadResolution(12); analogSetAttenuation(ADC_11db);

  initProperties();
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  Serial.println("[INFO] v3.8.3 AutoBaseBoot + fast capture");
}

void loop(){
  ArduinoCloud.update();

  float A_raw=readIrmsHPF(ADC_I_A,offA,V_PER_A_A)*calA;
  float B_raw=readIrmsHPF(ADC_I_B,offB,V_PER_A_B)*calB;
  float CT_raw=readIrmsHPF(ADC_I_ALL,offAll,V_PER_A_ALL);

  baseA=constrain(baseA,0.0f,0.5f);
  baseB=constrain(baseB,0.0f,0.5f);

  // --- AutoBaseBoot (ฉุกเฉิน): bases เป็น 0 และค่าดิบต่ำ → ตั้งฐานทันที ---
  if(baseA<0.005f && baseB<0.005f && A_raw<0.25f && B_raw<0.25f){
    baseA=A_raw; baseB=B_raw;
    Serial.printf("[AutoBaseBoot] baseA=%.3f baseB=%.3f\n",baseA,baseB);
  }

  // pre-comp currents
  float iA=A_raw-baseA; if(iA<0)iA=0; iA=deadzone(iA,DZ_A); if(iA<NO_LOAD_THRESHOLD)iA=0;
  float iB=B_raw-baseB; if(iB<0)iB=0; iB=deadzone(iB,DZ_B); if(iB<NO_LOAD_THRESHOLD)iB=0;
  if(RELAY_GATING){ if(!relayA) iA=0; if(!relayB) iB=0; }

  // raw-idle flags
  bool rawIdleA = (A_raw < baseA + RAW_IDLE_MARGIN_A);
  bool rawIdleB = (B_raw < baseB + RAW_IDLE_MARGIN_B);

  // activity (gate ด้วย rawIdle)
  if(iA>ACTIVATE_I && !rawIdleA){ if(++actCntA>=ACTIVATE_COUNT){ activeA=true; activeUntilA=millis()+ACTIVE_HOLD_MS; relCntA=0; } }
  else if(iA<RELEASE_I || rawIdleA){ if(++relCntA>=RELEASE_COUNT && millis()>activeUntilA){ activeA=false; actCntA=0; } }

  if(iB>ACTIVATE_I && !rawIdleB){ if(++actCntB>=ACTIVATE_COUNT){ activeB=true; activeUntilB=millis()+ACTIVE_HOLD_MS; relCntB=0; } }
  else if(iB<RELEASE_I || rawIdleB){ if(++relCntB>=RELEASE_COUNT && millis()>activeUntilB){ activeB=false; actCntB=0; } }

  // rise detectors
  if(iA>RISE_TRIG_I){ if(++riseCntA>=RISE_FRAMES){ unclampUntilA=millis()+UNCLAMP_HOLD_MS; activeA=true; } }
  else riseCntA=0;
  if(iB>RISE_TRIG_I){ if(++riseCntB>=RISE_FRAMES){ unclampUntilB=millis()+UNCLAMP_HOLD_MS; activeB=true; } }
  else riseCntB=0;

  if((A_raw-baseA)>RAW_RISE_TRIG_A){ if(++rawRiseCntA>=RAW_RISE_FRAMES){ unclampUntilA=millis()+UNCLAMP_HOLD_MS; activeA=true; } }
  else rawRiseCntA=0;
  if((B_raw-baseB)>RAW_RISE_TRIG_B){ if(++rawRiseCntB>=RAW_RISE_FRAMES){ unclampUntilB=millis()+UNCLAMP_HOLD_MS; activeB=true; } }
  else rawRiseCntB=0;

  // learn K
  learnK_BA(iA,iB,A_raw,B_raw);
  learnK_AB(iA,iB,A_raw,B_raw);

  // simultaneous solve
  float eps=1e-6f;
  float kBA_eff=max(0.0f,K_BA-0.05f);
  float kAB_eff=max(0.0f,K_AB-0.05f);
  const float DOM_RATIO=2.0f;
  float rAB=(iB>eps)?(iA/(iB+eps)):999.0f;
  float rBA=(iA>eps)?(iB/(iA+eps)):999.0f;
  if(rAB>DOM_RATIO) kBA_eff=0.0f;
  if(rBA>DOM_RATIO) kAB_eff=0.0f;
  const float CAP_FRAC=0.05f, CAP_ABS=0.01f;
  float maxSubB=min(CAP_FRAC*iB,CAP_ABS); if(iA>eps) kBA_eff=min(kBA_eff, maxSubB/(iA+eps));
  float maxSubA=min(CAP_FRAC*iA,CAP_ABS); if(iB>eps) kAB_eff=min(kAB_eff, maxSubA/(iB+eps));
  float denom=1.0f-kAB_eff*kBA_eff; if(denom<0.70f) denom=0.70f;
  float IA=(iA - kAB_eff*iB)/denom;
  float IB=(iB - kBA_eff*iA)/denom;
  if(IA<0) IA=0; if(IB<0) IB=0;

  // side-idle clamp (adaptive raw)
  bool otherActiveA=(IB>OTHER_ACTIVE_I);
  bool otherActiveB=(IA>OTHER_ACTIVE_I);
  bool allowClampA = !(activeA || (millis()<unclampUntilA));
  bool allowClampB = !(activeB || (millis()<unclampUntilB));
  if(allowClampA && ( !relayA || (rawIdleA && IA<SIDE_IDLE_I && !otherActiveA) )) IA=0.0f;
  if(allowClampB && ( !relayB || (rawIdleB && IB<SIDE_IDLE_I && !otherActiveB) )) IB=0.0f;

  if(IA<DZ_AFTER_COMP) IA=0.0f;
  if(IB<DZ_AFTER_COMP) IB=0.0f;

  // Fast on-relay capture: ดัน base เข้า raw เมื่อสงบ
  if(relayA && rawIdleA && IA < CAPTURE_MARGIN_A){
    if(!capSinceA) capSinceA=millis();
    if(millis()-capSinceA>CAPTURE_HOLD_MS){
      baseA = constrain((1.0f-CAPTURE_ALPHA)*baseA + CAPTURE_ALPHA*A_raw, 0.0f, 0.5f);
    }
  } else capSinceA=0;

  if(relayB && rawIdleB && IB < CAPTURE_MARGIN_B){
    if(!capSinceB) capSinceB=millis();
    if(millis()-capSinceB>CAPTURE_HOLD_MS){
      baseB = constrain((1.0f-CAPTURE_ALPHA)*baseB + CAPTURE_ALPHA*B_raw, 0.0f, 0.5f);
    }
  } else capSinceB=0;

  // publish
  float iAll=(allMode==MODE_SUM)?(IA+IB):deadzone(CT_raw,DZ_CT);
  iA_o=ema(iA_o,IA,EMA_ALPHA_OUT);
  iB_o=ema(iB_o,IB,EMA_ALPHA_OUT);
  iAll_o=ema(iAll_o,iAll,EMA_ALPHA_OUT);

  currentA=round2(floorToZero(iA_o));
  currentB=round2(floorToZero(iB_o));
  currentAll=round2(floorToZero(iAll_o));

  Serial.printf("Araw=%.3f baseA=%.3f actA=%d | Brow=%.3f baseB=%.3f actB=%d | IA=%.3f IB=%.3f | PUB=%.2f,%.2f,%.2f\n",
                A_raw,baseA,(int)activeA, B_raw,baseB,(int)activeB, IA,IB,
                currentA,currentB,currentAll);

  delay(300);
}

/*** Cloud ***/
void onMsgCommandChange(){
  if(!msgCommand.length()) return;
  String s=msgCommand; s.trim(); s.toUpperCase();
  if(s=="ZERO"){ doZero(); }
  if(s=="FORCE ZERO"){ // ตั้งฐานจาก raw ทันที
    // อ่านครั้งสั้น ๆ เพื่อกัน noise
    baseA=readIrmsHPF(ADC_I_A,offA,V_PER_A_A)*calA;
    baseB=readIrmsHPF(ADC_I_B,offB,V_PER_A_B)*calB;
    Serial.printf("[ForceZero] baseA=%.3f baseB=%.3f\n",baseA,baseB);
  }
  if(s=="MODE SUM"){ allMode=MODE_SUM; }
  if(s=="MODE CT"){  allMode=MODE_CT;  }
  if(s=="COMP ON"){  compEnabled=true; }
  if(s=="COMP OFF"){ compEnabled=false; }
  if(s.startsWith("CAL A =")){
    float t=s.substring(8).toFloat();
    float m=readIrmsHPF(ADC_I_A,offA,V_PER_A_A);
    if(m>0.0005f){ calA=t/m; Serial.printf("[Cal] calA=%.4f\n",calA); }
  }
  if(s.startsWith("CAL B =")){
    float t=s.substring(8).toFloat();
    float m=readIrmsHPF(ADC_I_B,offB,V_PER_A_B);
    if(m>0.0005f){ calB=t/m; Serial.printf("[Cal] calB=%.4f\n",calB); }
  }
  if(s.indexOf("A ON")>=0){ relayA=true;  onRelayAChange(); }
  if(s.indexOf("A OFF")>=0){ relayA=false; onRelayAChange(); }
  if(s.indexOf("B ON")>=0){ relayB=true;  onRelayBChange(); }
  if(s.indexOf("B OFF")>=0){ relayB=false; onRelayBChange(); }
}

void onRelayAChange(){
  bool level=RELAY_ACTIVE_LOW? !relayA:relayA;
  digitalWrite(RELAY_A_PIN, level?HIGH:LOW);
  if(!relayA && RELAY_GATING){ currentA=iA_o=0.0f; activeA=false; }
  Serial.printf("[Cloud] Relay A -> %s\n", relayA? "ON":"OFF");
}
void onRelayBChange(){
  bool level=RELAY_ACTIVE_LOW? !relayB:relayB;
  digitalWrite(RELAY_B_PIN, level?HIGH:LOW);
  if(!relayB && RELAY_GATING){ currentB=iB_o=0.0f; activeB=false; }
  Serial.printf("[Cloud] Relay B -> %s\n", relayB? "ON":"OFF");
}
void onResetEnergyChange(){
  if(resetEnergy){ resetEnergy=false; Serial.println("[Cloud] Energy reset."); }
}
