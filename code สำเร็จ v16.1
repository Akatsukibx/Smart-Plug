#include "thingProperties.h"
#include <Arduino.h>
#include <math.h>
#include <DHT.h>
#include <Wire.h>
#include <RTClib.h>
#include <Preferences.h>
#include <time.h>
#include <ArduinoJson.h>

/* ==== Google Sheet via GET ==== */
/** ส่วนเชื่อมต่อ Google Apps Script เพื่อส่ง/ดึงสถานะผ่าน HTTP GET */
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
const char* SCRIPT_URL   = "https://script.google.com/macros/s/AKfycbxgQ6cwYJ0MhaBw0UtUw2Z4p4vjSasI5ydXH5SY12cSYsjFK0Xpwe2Q3lXsrKuJrpD0/exec";
const char* SHEET_SECRET = "Smart_Plug";
const unsigned long POST_INTERVAL_MS = 60000UL;   // รอบเวลาการส่งข้อมูลขึ้นชีตปกติ (มิลลิวินาที)
unsigned long lastPostMs = 0;                     // เวลาโพสต์ครั้งล่าสุด
volatile bool needImmediatePost = false;          // ธงบังคับให้โพสต์ทันทีเมื่อมีเหตุสำคัญ (แจ้งเตือน/ปิดรอบ)
static bool tripA_flag = false;                   // ธงตัดกระแสเกินของ A (แนบไป payload)
static bool tripB_flag = false;                   // ธงตัดกระแสเกินของ B

/* ==== Reset Time Config ==== */
/** กำหนดเวลาตัดรอบ “รายวัน” และคาบแจ้งเตือน standby */
const int RESET_HOUR = 23;    // 0-23
const int RESET_MIN  = 59;    // 0-59
#define STBY_REPEAT_MIN 60    // แจ้งเตือนโหลดสแตนด์บายซ้ำทุกกี่นาที

// Weekly cutoff (0=Sun..6=Sat)
/** กำหนดวันสิ้นสุดรอบ “รายสัปดาห์” (0=อา ... 6=ส.) */
const int WEEKLY_DOW = 4;

/* ===== Monthly cutoff config ===== */
/** กำหนด “วันที่” ของเดือนที่ใช้เป็นวันตัดรอบรายเดือน (ถ้าเดือนนั้นมีวันน้อยกว่า จะตัดในวันสุดท้ายของเดือน) */
const int MONTHLY_DOM = 7;

/* ===== Pin map ===== */
/** แม็พขา I/O ของรีเลย์/ADC/I2C ให้ตรงกับบอร์ด */
#ifndef D2
#define D2 2
#endif
#ifndef D5
#define D5 5
#endif
#define RELAY_A_PIN D2
#define RELAY_B_PIN D5
#define RELAY_ON  HIGH
#define RELAY_OFF LOW

#define ADC_V_A    A0
#define ADC_V_B    A1
#define ADC_I_A    A3
#define ADC_I_B    A2
#define I2C_SDA    A4
#define I2C_SCL    A5
#define ADC_I_ALL  A6
#define ADC_V_ALL  A7

// DHT11
/** เซนเซอร์อุณหภูมิ/ความชื้น DHT11 */
#define DHTPIN   D8
#define DHTTYPE  DHT11
DHT dht(DHTPIN, DHTTYPE);

/* ===== ADC helpers ===== */
/** ฟังก์ชันช่วยอ่าน/แปลงค่า ADC และจัดการตัวเลขสวย ๆ สำหรับ UI/คำนวณ */
const float ADC_REF = 3.3f;
const int   ADC_MAX = 4095;
inline float adcToVolt(int raw){ return (ADC_REF * raw) / ADC_MAX; }          // แปลง ADC → Volt
inline int readADConce(int pin){ analogRead(pin); return analogRead(pin); }   // อ่าน ADC 2 ครั้งเพื่อลด jitter เฟรมแรก
float measureOffsetV(uint8_t pin,int n=400){ double s=0; for(int i=0;i<n;i++) s+=adcToVolt(readADConce(pin)); return s/n; }
auto round1=[](float x){ return roundf(x*10.0f)/10.0f; };    // ปัดทศนิยม 1 ตำแหน่ง
auto round2=[](float x){ return roundf(x*100.0f)/100.0f; };  // ปัดทศนิยม 2 ตำแหน่ง
auto zfloor=[](float x,float th){ return (fabsf(x)<th)?0.0f:x; }; // ทำ dead-zone ศูนย์

/* ===== Voltage calibration ===== */
/** ค่าคาลิเบรตแรงดัน: offset และอัตราส่วนสเกล ZMPT101B */
float vA_offsetV=2.50f, vB_offsetV=2.50f, vALL_offsetV=2.50f;
float vA_scaleV_perV=221.90f, vB_scaleV_perV=220.94f, vALL_scaleV_perV=223.36f;

/* ===== Current (counts RMS) ===== */
/** พารามิเตอร์คาลิเบรตกระแส (สเกล → แอมป์) และ bias แสดงผล (ตัด noise คงที่เล็กน้อยเวลาไม่มีโหลด) */
#ifndef ADC_BITS
#define ADC_BITS 12
#endif
#define ADC_FULL_SCALE ((float)((1<<ADC_BITS)-1))
float I_SCALE_A = 100.0f;
float I_SCALE_B = 100.0f;
float DISP_BIAS_A = 0.04f;
float DISP_BIAS_B = 0.04f;

/* === current baseline === */
/** ค่าฐาน (baseline) ของ noise กระแส และพารามิเตอร์การเรียนรู้อัตโนมัติเมื่อเงียบ */
float iA_base_norm = 0.0f;
float iB_base_norm = 0.0f;
const float BASE_MARGIN = 0.00020f;
const float BASE_ALPHA  = 0.30f;
const unsigned long BASE_HOLD_MS = 800;

/* ===== Accumulators ===== */
/** โครงสร้างสะสมค่าสถิติ: RMSCounts/CenterEMA ใช้กับ ADC กระแส, RMS ใช้กับแรงดันที่ตัด offset แล้ว */
struct RMSCounts { double sum=0.0, sum2=0.0; uint32_t n=0;
  inline void push(int x){ sum+=x; sum2+=(double)x*(double)x; n++; }
  inline float std_norm(){ if(!n) return 0.0f; double m=sum/n; double v=sum2/n - m*m; if(v<0) v=0; return (float)(sqrt(v)/ADC_FULL_SCALE); }
  inline void reset(){ sum=0; sum2=0; n=0; }
};
struct CenterEMA { double c=2048.0; bool init=false;
  inline void update(int x){ if(!init){ c=x; init=true; } else c = 0.02*x + 0.98*c; }
  inline float abs_dev_norm(int x){ update(x); double d=fabs((double)x - c); return (float)(d/ADC_FULL_SCALE); }
};
RMSCounts iA_cnt, iB_cnt; CenterEMA iA_ctr, iB_ctr;

struct RMS{ double sum=0,sum2=0; uint32_t n=0;
  inline void push(float x){ sum+=x; sum2+= (double)x*x; n++; }
  inline float rms() const { if(!n) return 0; double m=sum/n; double v=sum2/n - m*m; if(v<0) v=0; return sqrt(v); }
  inline void reset(){ sum=0; sum2=0; n=0; }
};
RMS vA_r, vB_r, vALL_r;

/* ===== EMA ===== */
/** ฟิลเตอร์ค่าเฉลี่ยเคลื่อนที่แบบ EMA สำหรับทำเลขแสดงผลนิ่ง */
struct EMA{ float y=0; bool init=false; float alpha=0.2f;
  void setTauSeconds(float tau){ if(tau<=0) alpha=1; else alpha = 1.0f - expf(-1.0f/tau); }
  float filt(float x){ if(!init){ y=x; init=true; } else y = alpha*x + (1-alpha)*y; return y; }
  void reset(){ init=false; }
};
EMA ema_iA,ema_iB,ema_iALL, ema_pA,ema_pB, ema_temp,ema_hum;
/** กำหนดค่า tau เริ่มต้นให้ตัวกรองทั้งหมด */
void setupSmoothers(){ float TAU=3.0f;
  ema_iA.setTauSeconds(TAU); ema_iB.setTauSeconds(TAU); ema_iALL.setTauSeconds(TAU);
  ema_pA.setTauSeconds(TAU); ema_pB.setTauSeconds(TAU);
  ema_temp.setTauSeconds(5.0f); ema_hum.setTauSeconds(5.0f);
}

/* ===== Overcurrent ===== */
/** ระบบตัดกระแสเกิน: เกณฑ์, margin, เวลาถือก่อนตัด, latch กันตัดซ้ำ และตัวจับเวลาเริ่มเกิน */
const float LIMIT_A = 10.0f, LIMIT_B = 10.0f;
const float LIMIT_MARGIN = 0.5f;
const unsigned long TRIP_HOLD_MS = 200;
bool latchedA=false, latchedB=false;
unsigned long aOverStart=0, bOverStart=0;

/* ===== System/energy & timers ===== */
/** ตัวสะสม/ตัวนับต่าง ๆ และพื้นที่ NVS (Preferences) */
double   sumW_A=0, sumW_B=0; uint32_t nW_A=0,  nW_B=0;
unsigned long last1s=0;
uint32_t capSinceA=0, capSinceB=0;
Preferences prefs;

volatile bool g_echoing=false;  // ป้องกัน feedback loop ตอน pushReply

/* ===== Alert sticky lock ===== */
/** ล็อกไม่ให้ส่ง Alert/Info ถี่เกินในช่วงเวลาหนึ่ง (กันสแปม UI) */
unsigned long g_alertLockUntilMs = 0;

/** ส่งข้อความตอบกลับ (msgReply) + sync Cloud แบบ one-shot ปลอดภัย */
inline void pushReply(const String& s){ msgReply=s; Serial.println("[Reply] "+s);
  g_echoing=true; msgCommand=s; ArduinoCloud.update(); g_echoing=false; }

/* ---- Helpers: ล้าง tail ดีบัก และ Sticky สำหรับ "แจ้งเตือนทั่วไป" ---- */
/** stripDebugTail: ตัดข้อความส่วน debug หลัง '@' ออกเพื่อความสวยงาม */
String stripDebugTail(String s){
  int p = s.indexOf('@');
  if (p >= 0) { s = s.substring(0, p); s.trim(); }
  return s;
}
/** setInfoMessageSticky: ข้อความประกาศทั่วไป (ไม่ใช่ ocAlert) พร้อมล็อกเวลาป้องกัน spam */
void setInfoMessageSticky(const String& s, unsigned long sticky_ms){
  String t = stripDebugTail(s);
  msgReply = t;                 // ไม่แตะ ocAlert
  needImmediatePost = true;
  g_alertLockUntilMs = millis() + sticky_ms;
  Serial.println("[Info*STICKY] " + t);
}

/* ---- Alerts (ความปลอดภัยเท่านั้น) ---- */
/** setAlertMessage: แจ้งเตือนความปลอดภัยแบบไม่ sticky (เคารพล็อกเวลา) */
void setAlertMessage(const String& s){
  static String last;
  if (millis() < g_alertLockUntilMs) return;  // still locked
  String t = stripDebugTail(s);
  if (t != last){
    msgReply = t; ocAlert  = t;               // ใส่ ocAlert → หมวดความปลอดภัย
    Serial.println("[Alert] " + t);
    last = t;
    needImmediatePost = true;
  }
}
/** setAlertMessageSticky: แจ้งเตือนความปลอดภัยแบบ sticky (ล็อกช่วงเวลา) */
void setAlertMessageSticky(const String& s, unsigned long sticky_ms){
  String t = stripDebugTail(s);
  msgReply = t; ocAlert = t;
  Serial.println("[Alert*STICKY] " + t);
  needImmediatePost = true;
  g_alertLockUntilMs = millis() + sticky_ms;
}

String fmt2(float x){ char b[16]; snprintf(b, sizeof(b), "%.2f", x); return String(b); }

/* ===== helpers ===== */
/** withUnit: แปะหน่วยและรูปแบบทศนิยมให้ตัวเลขเพื่อส่งขึ้นแดชบอร์ด */
String withUnit(float v, uint8_t digits, const char* unit) {
  char buf[24];
  dtostrf(v, 0, digits, buf);
  return String(buf) + " " + unit;
}

/* ===== Tips ===== */
/** ถุงข้อความคำแนะนำประหยัดพลังงานแบบสุ่ม */
const char* tips[] = {
  "ปิดปลั๊กเมื่อไม่ได้ใช้งาน",
  "ถอดที่ชาร์จออกเมื่อแบตเต็ม",
  "ตั้งเวลาปิดอัตโนมัติสำหรับอุปกรณ์ไฟฟ้า",
  "ปิดพัดลมเมื่อไม่อยู่ห้อง",
  "ถอดปลั๊กทีวี/กล่องดิจิทัลตอนนอน",
  "ไม่ทิ้งหม้อหุงข้าวค้างโหมดอุ่นนาน ๆ",
  "ใช้โหมดประหยัดพลังงานของคอมพิวเตอร์",
  "ปิดจอมอนิเตอร์ถ้าไม่ได้ใช้งาน",
  "ชาร์จมือถือกลางวันแทนชาร์จค้างคืน",
  "ใช้สายพ่วงที่มีสวิตช์ตัดไฟ",
  "ปิดจอมอนิเตอร์เมื่อไม่ใช้งาน",
  "ลองตั้งเวลาปิดอุปกรณ์ไฟฟ้าอัตโนมัติในช่วงนอน"
};
const int tipCount = sizeof(tips)/sizeof(tips[0]);
String getTip(){ int idx = (int)(millis()%tipCount); return String(tips[idx]); }

/* ===== Advice bag ===== */
/** เก็บ “คำแนะนำ” หลายรายการเพื่อรวมส่งในสรุปรายวัน */
String gAdviceSummary="";
void addAdvice(const String& line){
  if(line.length()==0) return;
  if(gAdviceSummary.length()>0) gAdviceSummary += " | ";
  gAdviceSummary += line;
}
void clearAdvice(){ gAdviceSummary = ""; }

/* ===== URL-encode ===== */
/** เข้ารหัสสตริงสำหรับ query param */
String urlEncode(const String &s) {
  String out = "";
  const char *hex = "0123456789ABCDEF";
  for (size_t i = 0; i < s.length(); i++) {
    unsigned char c = (unsigned char)s[i];
    if (('a'<=c && c<='z') || ('A'<=c && c<='Z') || ('0'<=c && c<='9') ||
        c=='-' || c=='_' || c=='.' || c=='~') {
      out += (char)c;
    } else if (c == ' ') {
      out += '+';
    } else {
      out += '%';
      out += hex[(c >> 4) & 0xF];
      out += hex[(c     ) & 0xF];
    }
  }
  return out;
}

/* ===== Rolling 7-day history (NVS) ===== */
/** เก็บประวัติพลังงาน 7 วันล่าสุดลง NVS เพื่อนำไปคำนวณ/แสดงเทรนด์ */
Preferences prefHist;
int hist7_load(float out[7]) {
  for (int i=0;i<7;i++) out[i]=0.0f;
  prefHist.begin("hist7", /*rw=*/true);
  uint8_t n     = prefHist.getUChar("n", 0);
  uint8_t head  = prefHist.getUChar("head", 0);
  int     ymd   = prefHist.getInt("ymd", 0); (void)ymd;
  if (n>7) n=7;
  for (uint8_t i=0;i<n;i++){
    uint8_t idx = (uint8_t)(( (head + 7) - n + i) % 7);
    String key  = String("v") + String((int)idx);
    out[i] = prefHist.getFloat(key.c_str(), 0.0f);
  }
  prefHist.end();
  return (int)n;
}
void hist7_push(float todayWh, int todayYmd) {
  prefHist.begin("hist7", /*rw=*/true);
  uint8_t n     = prefHist.getUChar("n", 0);
  uint8_t head  = prefHist.getUChar("head", 0);
  int     lastY = prefHist.getInt("ymd", 0);
  if (lastY == todayYmd) { prefHist.end(); return; }
  String key = String("v") + String((int)head);
  prefHist.putFloat(key.c_str(), (float)todayWh);
  head = (uint8_t)((head + 1) % 7);
  if (n < 7) n++;
  prefHist.putUChar("head", head);
  prefHist.putUChar("n", n);
  prefHist.putInt("ymd", todayYmd);
  prefHist.end();
  Serial.printf("[HIST7] push ymd=%d val=%.2f (n=%u head=%u)\n", todayYmd, todayWh, n, head);
}

/* ===== RTC / Time ===== */
/** จัดการเวลา: ใช้ NTP เป็นหลัก รองลงมาคือ RTC DS3231 และ fallback = เวลาคอมไพล์ + uptime */
RTC_DS3231 rtc; bool rtcOK=false, ntpOK=false;
const long TZ_OFFSET_SEC = 7L*3600L; // Asia/Bangkok
static inline uint32_t compileUTC(){ DateTime c(F(__DATE__),F(__TIME__)); return c.unixtime(); }
inline uint32_t nowUtc(){ time_t t=time(nullptr); if(ntpOK && t>1700000000) return (uint32_t)t;
  if(rtcOK) return rtc.now().unixtime(); static uint32_t boot=0; if(!boot) boot=compileUTC(); return boot + millis()/1000UL; }

/* ===== time utils (TH) ===== */
/** สร้างข้อความ “อีก xx นาที/ชั่วโมง” ภาษาไทยสำหรับเวลานัดหมาย */
String humanDeltaTH_fromSeconds(uint32_t d){ if((int32_t)d<=0) return "เดี๋ยวนี้";
  unsigned long s=d,h=s/3600; s%=3600; unsigned long m=s/60; s%=60; if(s>0)m++;
  if(m>=60){ h+=m/60; m%=60; } String out="อีก "; if(h){ out+=String(h)+" ชั่วโมง"; if(m) out+=" "+String(m)+" นาที"; }
  else if(m) out+=String(m)+" นาที"; else out+="น้อยกว่า 1 นาที"; return out; }
String formatWhenRelativeUTC(uint32_t t){ uint32_t n=nowUtc(); return humanDeltaTH_fromSeconds(t>n?t-n:0); }

/* ==== DOW helper ==== */
/** คำนวณวันในสัปดาห์ตามเวลาท้องถิ่น (0=อาทิตย์ ... 6=เสาร์) */
int dowSun0_local() {
  time_t lt = (time_t)nowUtc() + TZ_OFFSET_SEC;
  struct tm tmv;
  gmtime_r(&lt, &tmv);
  return tmv.tm_wday;     // 0=Sun..6=Sat
}

/* ===== Monthly helpers ===== */
/** ฟังก์ชันช่วยเรื่องเดือน: ปีอธิกสุรทิน/วันสุดท้ายของเดือน/เช็ควันตัดรอบเดือนตรงวันนี้ไหม */
static inline bool isLeap(int y){ return ((y%4==0) && (y%100!=0)) || (y%400==0); }
static inline int lastDayOfMonth(int y, int m){
  static const int d[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
  if (m==2) return isLeap(y) ? 29 : 28;
  return d[m-1];
}
static inline bool isMonthlyCutoffToday(const DateTime& loc){
  int ld = lastDayOfMonth(loc.year(), loc.month());
  int dom = MONTHLY_DOM <= ld ? MONTHLY_DOM : ld;
  return loc.day() == dom;
}

/* ===== Timers (UTC) + status text ===== */
/** ตัวตั้งเวลา (นัดเปิด/ปิด) ของ A/B/ALL และตัวช่วยบันทึก/โหลด/ตรวจเวลาครบกำหนด */
uint32_t A_onAt_s=0,A_offAt_s=0,B_onAt_s=0,B_offAt_s=0;
bool showNextA=false, showNextB=false, showNextAll=false, showOnlyAll=false;
void saveTimers(){ prefs.begin("timers",false);
  prefs.putUInt("A_on",A_onAt_s); prefs.putUInt("A_off",A_offAt_s);
  prefs.putUInt("B_on",B_onAt_s); prefs.putUInt("B_off",B_offAt_s); prefs.end(); }
void loadTimers(){ prefs.begin("timers",true);
  A_onAt_s=prefs.getUInt("A_on",0); A_offAt_s=prefs.getUInt("A_off",0);
  B_onAt_s=prefs.getUInt("B_on",0); B_offAt_s=prefs.getUInt("B_off",0); prefs.end(); }
inline bool due(uint32_t when_s,uint32_t now_s){ return (when_s!=0)&&((int32_t)(now_s-when_s)>=0); }
int clampMinutes(int m){ if(m<0)return 0; if(m>1440)return 1440; return m; }

/* ===== Parser / Command ===== */
/** ส่วน parser คำสั่งธรรมชาติ (ไทย/อังกฤษ) แยก token, ตรวจ “at HH:MM” และ “N นาที/ชั่วโมง” */
String normalizeSpaces(String s){
  s.trim();
  const char* specials[] = { "\xC2\xA0", "\xE2\x80\x8B", "\xE2\x80\x8C", "\xE2\x80\x8D" };
  for (const char* pat : specials) while (s.indexOf(pat) >= 0) s.replace(pat, " ");
  while (s.indexOf("  ") >= 0) s.replace("  ", " ");
  return s;
}
String toUpperAscii(String s){ for(size_t i=0;i<s.length();++i){ char c=s[i]; if(c>='a'&&c<='z') s[i]=c-32; } return s; }
void split3Tokens(const String& s,String& t1,String& t2,String& t3){
  int p1=s.indexOf(' ');
  if(p1<0){ t1=s; t2=""; t3=""; return; }
  t1=s.substring(0,p1);
  int p2=s.indexOf(' ', p1+1);
  if(p2<0){ t2=s.substring(p1+1); t3=""; return; }
  t2=s.substring(p1+1,p2);
  t3=s.substring(p2+1);
}
bool isAny(const String& token,const char* a,const char* b,const char* c){
  String T=toUpperAscii(token);
  if(a){String A=a; if(toUpperAscii(A)==T||token==A) return true;}
  if(b){String B=b; if(toUpperAscii(B)==T||token==B) return true;}
  if(c){String C=c; if(toUpperAscii(C)==T||token==C) return true;}
  return false;
}
String join(const char* a[],int n){ String s; for(int i=0;i<n;i++){ if(i) s+=" | "; s+=a[i]; } return s; }
void showSuggestions(char which){
  if(which=='?'){ const char* root[]={(char*)"A ...",(char*)"B ...",(char*)"All ...",(char*)"help"};
    pushReply("Try: "+join(root,4)+"\nตัวอย่าง: A เปิด 2 ชั่วโมง 30 นาที, B ปิด 30 นาที, All on at 21:30"); return; }
  const char* th[]={(char*)"เปิด [เวลา]",(char*)"ปิด [เวลา]",(char*)"ยกเลิก"}; const char* en[]={(char*)"on [time]",(char*)"off [time]",(char*)"cancel"};
  String head=(which=='A')?"A":(which=='B')?"B":"All";
  pushReply(head+" → "+join(th,3)+"\nEN: "+head+" "+join(en,3)+"\n[เวลา]= 30 นาที | 1 ชั่วโมง | 2 ชั่วโมง 30 นาที | at 21:30");
}
int extractFirstInt(const String& s){ String d=""; for(size_t i=0;i<s.length();++i){ char c=s[i]; if(c>='0'&&c<='9') d+=c; else if(d.length()) break; } return d.length()? d.toInt():-1; }
bool hasHourUnit(String s){
  String u=toUpperAscii(s);
  if(u.indexOf("HR")>=0||u.indexOf("H ")>=0||u.endsWith("H")) return true;
  if(s.indexOf("ชั่วโมง")>=0||s.indexOf("ชม.")>=0) return true;
  return false;
}
bool hasMinuteUnit(String s){
  String u=toUpperAscii(s);
  if(u.indexOf("MIN")>=0 || u=="M" || u.endsWith(" M")) return true;
  if(s.indexOf("นาที")>=0) return true;
  return false;
}
int parseDurationToMinutes(String s){
  s=normalizeSpaces(s); s.replace("อีก",""); s.trim(); int total=0,pos=0;
  while(pos<(int)s.length()){
    while(pos<(int)s.length()&&s[pos]==' ') pos++;
    int ns=s.indexOf(' ',pos);
    String token=(ns<0)? s.substring(pos): s.substring(pos,ns);
    pos=(ns<0)? s.length(): ns+1;
    int v=extractFirstInt(token); if(v<0) continue; bool handled=false;
    if(hasHourUnit(token)){ total+=v*60; handled=true; }
    else if(hasMinuteUnit(token)){ total+=v; handled=true; }
    else{
      int ns2=s.indexOf(' ',pos); String next=(ns2<0)? s.substring(pos): s.substring(pos,ns2);
      if(next.length()){
        if(hasHourUnit(next)){ total+=v*60; handled=true; pos=(ns2<0? s.length(): ns2+1); }
        else if(hasMinuteUnit(next)){ total+=v; handled=true; pos=(ns2<0? s.length(): ns2+1); }
      }
    }
    if(!handled) total+=v;
  }
  return clampMinutes(total);
}
bool hasAtKeyword(String s){
  s=normalizeSpaces(s); String u=toUpperAscii(s);
  if(u.indexOf(" AT ")>=0 || u.startsWith("AT ") || u.endsWith(" AT")) return true;
  if (s.indexOf("เวลา")>=0) return true; return false;
}
bool findHHMM(const String& s,int& hh,int& mm){
  int c=s.indexOf(':'); if(c<0) return false; int l=c-1; while(l>=0 && isDigit(s[l])) l--; l++;
  int r=c+1; while(r<(int)s.length() && isDigit(s[r])) r++; String H=s.substring(l,c), M=s.substring(c+1,r);
  if(H.length()==0||M.length()<1) return false; int h=H.toInt(), m=M.toInt(); if(h<0||h>23||m<0||m>59) return false; hh=h; mm=m; return true;
}
uint32_t parseLocalHHMM_toUTC(const String& tail){
  int hh=-1,mm=-1; if(!findHHMM(tail,hh,mm)) return 0; uint32_t now=nowUtc();
  DateTime nowL(now+TZ_OFFSET_SEC); DateTime tgtL(nowL.year(),nowL.month(),nowL.day(),hh,mm,0);
  uint32_t tgt=tgtL.unixtime()-TZ_OFFSET_SEC; if((int32_t)(tgt-now)<=0) tgt=(tgtL+TimeSpan(1,0,0,0)).unixtime()-TZ_OFFSET_SEC; return tgt;
}

/* ===== Actions / status ===== */
/** ตัวช่วยจัดรูปประโยคและดำเนินการตั้งเวลา */
String whoStr(char w){ return String((w=='X')?"ALL":(w=='A'?"A":"B")); }
String actFutureTH(bool on){ return String(on? "จะเปิด":"จะปิด"); }

/* ==== ▼ ส่วนตั้งเวลา (idempotent + already) ▼ ==== */
/** ตอบกลับเมื่อสั่งสถานะที่เป็นอยู่แล้ว เพื่อหลีกเลี่ยงการตั้งเวลาซ้ำซ้อน */
void replyAlready(char which, bool turnOn){
  String label = (which=='X') ? "ALL" : (which=='A' ? "A" : "B");
  String already = turnOn ? "เปิดอยู่แล้ว" : "ปิดอยู่แล้ว";

  if (which == 'X') {
    if (relayA == turnOn && relayB == turnOn) {
      pushReply("ALL → " + already + " (A+B)");
    } else if (relayA == turnOn && relayB != turnOn) {
      pushReply("A → " + already + " | ตั้งเวลาให้เฉพาะ B");
    } else if (relayB == turnOn && relayA != turnOn) {
      pushReply("B → " + already + " | ตั้งเวลาให้เฉพาะ A");
    }
  } else {
    pushReply(label + " → " + already);
  }
}

/** scheduleAction: ตั้งให้ “อีก N นาที” จะเปิด/ปิด A/B/ALL */
void scheduleAction(char which, bool turnOn, int minutes){
  minutes = clampMinutes(minutes);

  if (which == 'A' && (relayA == turnOn) && minutes > 0) { replyAlready('A', turnOn); return; }
  if (which == 'B' && (relayB == turnOn) && minutes > 0) { replyAlready('B', turnOn); return; }
  if (which == 'X' && (relayA == turnOn) && (relayB == turnOn) && minutes > 0) { replyAlready('X', turnOn); return; }

  uint32_t when = nowUtc() + (uint32_t)minutes * 60UL;

  if (which=='A' || which=='X') {
    if (relayA != turnOn || minutes == 0) {
      if (turnOn) A_onAt_s  = (minutes==0) ? nowUtc() : when;
      else        A_offAt_s = (minutes==0) ? nowUtc() : when;
    }
  }
  if (which=='B' || which=='X') {
    if (relayB != turnOn || minutes == 0) {
      if (turnOn) B_onAt_s  = (minutes==0) ? nowUtc() : when;
      else        B_offAt_s = (minutes==0) ? nowUtc() : when;
    }
  }

  if (which=='A')      showNextA   = (minutes > 0);
  else if (which=='B') showNextB   = (minutes > 0);
  else if (which=='X'){ showNextAll = (minutes > 0); showNextA = showNextB = false; showOnlyAll=true; }

  saveTimers();

  if (minutes == 0) pushReply(whoStr(which) + " " + actFutureTH(turnOn) + " เดี๋ยวนี้");
  else pushReply(whoStr(which) + " " + actFutureTH(turnOn) + " " + formatWhenRelativeUTC(when));
}

/** scheduleActionAt: ตั้งแบบ “at HH:MM” (เวลาท้องถิ่น) */
void scheduleActionAt(char which, bool turnOn, uint32_t when){
  if (which == 'A' && (relayA == turnOn) && when > nowUtc()) { replyAlready('A', turnOn); return; }
  if (which == 'B' && (relayB == turnOn) && when > nowUtc()) { replyAlready('B', turnOn); return; }
  if (which == 'X' && (relayA == turnOn) && (relayB == turnOn) && when > nowUtc()) { replyAlready('X', turnOn); return; }

  if (which=='A' || which=='X') {
    if (relayA != turnOn) { if (turnOn) A_onAt_s = when; else A_offAt_s = when; }
  }
  if (which=='B' || which=='X') {
    if (relayB != turnOn) { if (turnOn) B_onAt_s = when; else B_offAt_s = when; }
  }

  if (which=='A')      showNextA   = (when > nowUtc());
  else if (which=='B') showNextB   = (when > nowUtc());
  else if (which=='X'){ showNextAll = (when > nowUtc()); showNextA = showNextB = false; showOnlyAll=true; }

  saveTimers();
  pushReply(whoStr(which) + " " + actFutureTH(turnOn) + " " + formatWhenRelativeUTC(when));
}
/* ==== ▲ จบส่วนตั้งเวลา ▲ ==== */

/* ===== Status text ===== */
/** สร้างข้อความสถานะสรุปเวลา “จะเปิด/จะปิด” สำหรับปลั๊กแต่ละช่อง/ทั้งหมด */
String relStr(uint32_t when){ if(!when) return ""; return formatWhenRelativeUTC(when); }
String nextABText(char w){ uint32_t onT=(w=='A')?A_onAt_s:B_onAt_s, offT=(w=='A')?A_offAt_s:B_offAt_s;
  if(!onT && !offT) return ""; if(onT && (!offT || (int32_t)(onT-offT)<0)) return String("(จะเปิด ")+relStr(onT)+")";
  return String("(จะปิด ")+relStr(offT)+")"; }
String nextALLText(){ uint32_t tmin=0; bool isOn=false; uint32_t ts[4]={A_onAt_s,A_offAt_s,B_onAt_s,B_offAt_s}; bool ton[4]={true,false,true,false};
  for(int i=0;i<4;i++){ if(!ts[i]) continue; if(!tmin || (int32_t)(ts[i]-tmin)<0){ tmin=ts[i]; isOn=ton[i]; } }
  if(!tmin) return ""; return String(isOn? "จะเปิด ":"จะปิด ")+relStr(tmin);
}
void updateStatusNow(){
  if(showOnlyAll){
    String t=nextALLText();
    String line = t.length()? ("All: "+t) : (String("All: ")+( (relayA||relayB)?"เปิดใช้งาน":"ปิดใช้งาน"));
    if(statusNow!=line){ statusNow=line; Serial.println(String("[Status] ")+statusNow); }
    return;
  }
  String aState=relayA?"เปิดใช้งาน":"ปิดใช้งาน";
  String bState=relayB?"เปิดใช้งาน":"ปิดใช้งาน";
  String msg="Plug A: "+aState; if(showNextA){ String t=nextABText('A'); if(t.length()) msg+=" "+t; }
  msg+="\nPlug B: "+bState; if(showNextB){ String t=nextABText('B'); if(t.length()) msg+=" "+t; }
  if(showNextAll){ String t=nextALLText(); if(t.length()) msg+="\nAll: "+t; }
  if(statusNow!=msg){ statusNow=msg; Serial.println(String("[Status] ")+msg); }
}

/* ==== baseline helpers ==== */
/** วัด baseline ของ noise กระแสเพื่อใช้ตัดออกจากการคำนวณกระแสจริง */
float measureCurrentBaseNorm(uint8_t pin, int N=1200){
  double s=0, s2=0;
  for(int i=0;i<N;i++){ int x=analogRead(pin); s+=x; s2+=(double)x*(double)x; delayMicroseconds(500); }
  double m=s/N; double v=s2/N - m*m; if(v<0) v=0; return (float)(sqrt(v)/ADC_FULL_SCALE);
}

/* ===== Energy summaries ===== */
/** ตัวแปรพลังงานสะสมของวัน/สัปดาห์/เดือน และค่า “รอบก่อน” เพื่อเทียบเปอร์เซ็นต์ */
double g_dailyWh=0.0, g_weeklyWh=0.0, g_monthWh=0.0;
double g_dailyWhPrev=0.0, g_weeklyWhPrev=0.0, g_monthWhPrev=0.0;
uint16_t lastResetY=0, lastResetM=0, lastResetD=0;
bool didResetToday=false;

/* === Restore mode === */
/** โหมดกู้คืนพลังงานจาก NVS:
 *  1 = กู้คืนเฉพาะเมื่อ ymd ตรงวันนี้
 *  2 = กู้คืนเสมอ (ป้องกันการหายเมื่อไฟหลุด) */
#define ENERGY_RESTORE_MODE 2

/* ==== NEW: Month seeding helper (เดือน ≥ วัน เท่านั้น) ==== */
/** อนุญาตให้ “เด้งค่าเดือนขึ้นมาไม่ต่ำกว่าวัน” เฉพาะก่อนถึงวันตัดรอบเดือนเท่านั้น */
bool allowMonthSeed = true;

/** seedMonthFromDailyOnly: บังคับกฎ month >= day โดยไม่อิงค่าสัปดาห์ */
static inline bool seedMonthFromDailyOnly() {
  if (!allowMonthSeed) return false;
  if (g_dailyWh > g_monthWh + 1e-6) {
    g_monthWh   = g_dailyWh;
    monthWh     = roundf(g_monthWh*100.0f)/100.0f;
    monthWh_str = withUnit((float)g_monthWh, 2, "Wh");
    monthPct    = (monthWhPrev>0.0f)?((monthWh-monthWhPrev)/monthWhPrev)*100.0f:0.0f;
    needImmediatePost = true;
    return true;
  }
  return false;
}

/* ==== Flags for daily/weekly/monthly posts ==== */
/** ธงบอกว่าเพิ่งปิดรอบวัน/สัปดาห์/เดือน เพื่อให้ postToGoogleSheet ส่งแพ็กสรุปเฉพาะกิจ */
bool g_justDailyReset = false;
bool g_clearAdviceAfterPost = false;
bool g_justWeeklyReset = false;
bool g_justMonthlyReset = false;

/* ==== Weekly/monthly announce control ==== */
/** กันส่งซ้ำในนาทีตัดรอบ: weeklyRolledToday/lastWeeklySentKey และ monthlyRolledThisMonth/lastMonthlySentKey */
bool weeklyRolledToday = false;
int  lastWeeklySentKey = 0;
bool monthlyRolledThisMonth = false;
int  lastMonthlySentKey = 0;

static inline int ymd_from_DateTime(const DateTime& dt){
  return dt.year()*10000 + dt.month()*100 + dt.day();
}
static inline int makeYmd(DateTime loc){
  return loc.year()*10000 + loc.month()*100 + loc.day();
}
static inline int makeYmdHM(DateTime loc){
  return loc.year()*100000000 + loc.month()*1000000 + loc.day()*10000 + loc.hour()*100 + loc.minute();
}

/* ==== Weekly summary (patched) ==== */
/** ประกอบข้อความสรุปรายสัปดาห์ (เทียบ % กับสัปดาห์ก่อน), ตั้งธงส่ง, อาจ rollover ค่า และประกาศ Sticky */
void sendWeeklySummary(bool doRollover){
  float thisW = (float)round2(g_weeklyWh);
  float lastW = (float)round2(g_weeklyWhPrev);

  String ws = "ใช้ไฟสัปดาห์นี้: " + String(thisW, 2) + " Wh";
  if (lastW > 0.0009f) {
    float diffPct = ((thisW - lastW) / lastW) * 100.0f;
    ws += (diffPct >= 0.0f ? " เพิ่มขึ้น " : " ลดลง ");
    ws += String((float)roundf(fabs(diffPct))) + "% จากสัปดาห์ก่อน";
  } else {
    ws += " 0% (สัปดาห์แรก)";
  }
  ws += " | แนะนำ: " + getTip();

  weeklySummary     = ws;
  g_justWeeklyReset = true;
  needImmediatePost = true;

  ArduinoCloud.update();
  setInfoMessageSticky(ws, 120000UL);

  if (doRollover) {
    g_weeklyWhPrev = g_weeklyWh;
    g_weeklyWh     = 0.0;
    weeklyRolledToday = true;
  }
  Serial.println(String("[WEEKLY] ") + ws + (doRollover ? " (ROLLOVER)" : " (ANNOUNCE ONLY)"));
}

/* ==== Monthly summary (reworked) ==== */
/** ประกอบข้อความสรุปรายเดือน (เทียบ % กับเดือนก่อน), ตั้งธงส่ง, อาจ rollover ค่า และประกาศ Sticky */
void sendMonthlySummary(bool doRollover){
  float thisM = (float)round2(g_monthWh);
  float lastM = (float)round2(g_monthWhPrev);

  String ms = "ใช้ไฟเดือนนี้: " + String(thisM, 2) + " Wh";
  if (lastM > 0.0009f) {
    float diffPct = ((thisM - lastM) / lastM) * 100.0f;
    ms += (diffPct >= 0.0f ? " เพิ่มขึ้น " : " ลดลง ");
    ms += String((float)roundf(fabs(diffPct))) + "% จากเดือนก่อน";
  } else {
    ms += " 0% (เดือนแรก)";
  }
  ms += " | แนะนำ: " + getTip();

  monthlySummary     = ms;
  g_justMonthlyReset = true;
  needImmediatePost  = true;

  ArduinoCloud.update();
  setInfoMessageSticky(ms, 120000UL);

  if (doRollover && !monthlyRolledThisMonth) {
    g_monthWhPrev = g_monthWh;
    g_monthWh     = 0.0;
    monthlyRolledThisMonth = true;
    allowMonthSeed = false;  // กันเดือนเด้งกลับหลังปิดรอบ
  }

  Serial.println(String("[MONTHLY] ") + ms + (doRollover ? " (ROLLOVER)" : " (ANNOUNCE ONLY)"));
}

/* === PERSIST ENERGY =========================================== */
/** บันทึกสถานะพลังงานลง NVS แบบ periodic/step เพื่อกันข้อมูลหายเมื่อไฟดับ */
Preferences prefEnergy;
const unsigned long ENERGY_SAVE_INTERVAL_MS = 60000UL;
const float ENERGY_SAVE_STEP_WH = 0.10f;
unsigned long lastEnergySaveMs = 0;
double lastSavedDaily = 0.0, lastSavedWeekly = 0.0, lastSavedMonthly = 0.0;

// Forward declaration
void persistEnergyIfNeeded();

/*** NEW: sheet-pull guards ***/
/** ธง/ตัวจับเวลา การดึงข้อมูลจากชีตตอนบูต (ทำครั้งเดียว) */
static bool g_sheetPullDone = false;
static bool g_sheetPullTried = false;
static unsigned long g_bootMs = 0;

/** โหลดสถานะพลังงานจาก NVS + ดึงจากชีต (ครั้งเดียวตอนบูต) + บังคับ month>=day */
void loadEnergyStateAtBoot(){
  prefEnergy.begin("energy", /*rw=*/false);
  int   savedYmd      = prefEnergy.getInt("ymd", 0);
  float savedDailyWh  = prefEnergy.getFloat("dWh", 0.0f);
  float savedWeeklyWh = prefEnergy.getFloat("wWh", 0.0f);
  float savedMonthWh  = prefEnergy.getFloat("mWh", 0.0f);
  float savedMonthWhPrev = prefEnergy.getFloat("mWhPrev", 0.0f);
  int   savedLastY    = prefEnergy.getInt("lastY", 0);
  int   savedLastM    = prefEnergy.getInt("lastM", 0);
  int   savedLastD    = prefEnergy.getInt("lastD", 0);
  bool  savedDid      = prefEnergy.getBool("did", false);
  prefEnergy.end();

  DateTime loc(nowUtc() + TZ_OFFSET_SEC);
  int today = ymd_from_DateTime(loc);

  Serial.printf("[NVS] ymd=%d saved dWh=%.2f wWh=%.2f mWh=%.2f today=%d\n",
                savedYmd, savedDailyWh, savedWeeklyWh, savedMonthWh, today);

  if (ENERGY_RESTORE_MODE == 1){
    if (savedYmd == today){
      g_dailyWh  = (double)savedDailyWh;
      g_weeklyWh = (double)savedWeeklyWh;
      g_monthWh  = (double)savedMonthWh;
    }
  } else {
    g_dailyWh  = (double)savedDailyWh;
    g_weeklyWh = (double)savedWeeklyWh;
    g_monthWh  = (double)savedMonthWh;
  }
  g_monthWhPrev = (double)savedMonthWhPrev;

  dailyWh  = roundf(g_dailyWh*100.0f)/100.0f;
  weeklyWh = roundf(g_weeklyWh*100.0f)/100.0f;

  if (savedLastY){
    lastResetY = (uint16_t)savedLastY;
    lastResetM = (uint16_t)savedLastM;
    lastResetD = (uint16_t)savedLastD;
    didResetToday = savedDid;
  } else {
    lastResetY = loc.year(); lastResetM = loc.month(); lastResetD = loc.day();
    didResetToday = false;
  }

  lastEnergySaveMs = millis();
  lastSavedDaily   = g_dailyWh;
  lastSavedWeekly  = g_weeklyWh;
  lastSavedMonthly = g_monthWh;

  // ==== ดึงจาก Google Sheet (one-shot ใน boot) ====
  if (WiFi.status() == WL_CONNECTED) {
    WiFiClientSecure client; client.setInsecure();
    HTTPClient https;

    String url = String(SCRIPT_URL) + "?k=" + SHEET_SECRET + "&ct=pull_state";
    if (https.begin(client, url)) {
      int code = https.GET();
      String payload = https.getString();
      https.end();

      if (code == 200) {
        DynamicJsonDocument doc(384);
        DeserializationError err = deserializeJson(doc, payload);
        if (!err && doc["ok"]) {
          g_sheetPullTried = true;
          g_sheetPullDone  = true;

          float sd  = doc["dWh"]     | 0.0f;
          float sw  = doc["wWh"]     | 0.0f;
          float sm  = doc["mWh"]     | 0.0f;
          float sdp = doc["dWhPrev"] | 0.0f;
          float swp = doc["wWhPrev"] | 0.0f;
          float smp = doc["mWhPrev"] | 0.0f;

          bool updated=false;
          if (sd > g_dailyWh)  { g_dailyWh  = sd;  updated=true; }
          if (sw > g_weeklyWh) { g_weeklyWh = sw;  updated=true; }
          if (sm > g_monthWh)  { g_monthWh  = sm;  updated=true; }

          g_dailyWhPrev  = sdp;
          g_weeklyWhPrev = swp;
          g_monthWhPrev  = smp;

          dailyWh      = roundf(g_dailyWh*100.0f)/100.0f;
          weeklyWh     = roundf(g_weeklyWh*100.0f)/100.0f;
          monthWh      = roundf(g_monthWh*100.0f)/100.0f;

          dailyWhPrev  = roundf(g_dailyWhPrev*100.0f)/100.0f;
          weeklyWhPrev = roundf(g_weeklyWhPrev*100.0f)/100.0f;
          monthWhPrev  = roundf(g_monthWhPrev*100.0f)/100.0f;
          monthPct     = (monthWhPrev>0.0f)?((monthWh-monthWhPrev)/monthWhPrev)*100.0f:0.0f;

          dailyWh_str      = withUnit(dailyWh,      2, "Wh");
          weeklyWh_str     = withUnit(weeklyWh,     2, "Wh");
          monthWh_str      = withUnit(monthWh,      2, "Wh");
          dailyWhPrev_str  = withUnit(dailyWhPrev,  2, "Wh");
          weeklyWhPrev_str = withUnit(weeklyWhPrev, 2, "Wh");
          monthWhPrev_str  = withUnit(monthWhPrev,  2, "Wh");
          ArduinoCloud.update();

          if (updated) persistEnergyIfNeeded();
          Serial.printf("[SheetPull@boot] d=%.2f w=%.2f m=%.2f (prev d=%.2f w=%.2f m=%.2f)\n",
                        (float)dailyWh,(float)weeklyWh,(float)monthWh,
                        (float)dailyWhPrev,(float)weeklyWhPrev,(float)monthWhPrev);
        } else {
          Serial.printf("[SheetPull@boot] JSON parse/ok fail: %s\n", err.c_str());
        }
      } else {
        Serial.printf("[SheetPull@boot] HTTP %d\n", code);
      }
    }
  }

  // --- บังคับ month>=day หลัง restore/pull (เฉพาะเมื่ออนุญาต)
  if (seedMonthFromDailyOnly()) {
    ArduinoCloud.update();
    persistEnergyIfNeeded();
  }
}

/** persistEnergyIfNeeded: เซฟลง NVS เมื่อถึงเวลา/มีการเปลี่ยนมากพอ */
void persistEnergyIfNeeded(){
  if (!g_sheetPullDone && (millis() - g_bootMs) < 20000UL) {
    return;
  }
  unsigned long ms = millis();
  bool timeUp = (ms - lastEnergySaveMs) >= ENERGY_SAVE_INTERVAL_MS;
  bool stepUp = (g_dailyWh - lastSavedDaily) >= (double)ENERGY_SAVE_STEP_WH
             || (g_weeklyWh - lastSavedWeekly) >= (double)ENERGY_SAVE_STEP_WH
             || (g_monthWh  - lastSavedMonthly)>= (double)ENERGY_SAVE_STEP_WH;
  if (!timeUp && !stepUp) return;

  DateTime loc(nowUtc() + TZ_OFFSET_SEC);
  int today = ymd_from_DateTime(loc);

  prefEnergy.begin("energy", /*rw=*/true);
  prefEnergy.putInt("ymd", today);
  prefEnergy.putFloat("dWh",  (float)g_dailyWh);
  prefEnergy.putFloat("wWh",  (float)g_weeklyWh);
  prefEnergy.putFloat("mWh",  (float)g_monthWh);
  prefEnergy.putFloat("mWhPrev", (float)g_monthWhPrev);
  prefEnergy.putInt("lastY",  (int)lastResetY);
  prefEnergy.putInt("lastM",  (int)lastResetM);
  prefEnergy.putInt("lastD",  (int)lastResetD);
  prefEnergy.putBool("did",   didResetToday);
  prefEnergy.end();

  lastEnergySaveMs = ms;
  lastSavedDaily   = g_dailyWh;
  lastSavedWeekly  = g_weeklyWh;
  lastSavedMonthly = g_monthWh;

  Serial.printf("[NVS SAVE] ymd=%d dWh=%.2f wWh=%.2f mWh=%.2f (%s)\n",
                today, (float)g_dailyWh, (float)g_weeklyWh, (float)g_monthWh,
                timeUp ? "interval" : "step");
}
/* === END PERSIST ENERGY ======================================= */

/* ===== Voltage smoothing (±1V deadband + 0.5V quant + EMA) ==== */
/** ทำให้ค่าที่แสดงผลแรงดันนิ่งขึ้น: quant 0.5V + deadband ±1V + EMA */
struct SmoothY { bool init=false; float last=0.0f; };
inline float quant05(float x){ return roundf(x*2.0f)/2.0f; }
static float smoothVoltDB(struct SmoothY &s, float raw){
  float q = quant05(raw);
  if(!s.init){ s.init=true; s.last=q; return q; }
  if (fabsf(q - s.last) < 1.0f) return s.last;
  const float alpha = 0.6f;
  s.last = alpha*q + (1.0f-alpha)*s.last;
  return s.last;
}
static SmoothY svA, svB, svAll;
/* ============================================================= */

/* ==== NEW: pull latest energy from Google Sheet ==== */
/** ดึงสถานะล่าสุดจากชีต (สำรองอีกชั้น นอกเหนือจากตอนบูต) และ sync เข้าตัวแปร/Cloud */
bool pullLatestFromSheet(){
  WiFiClientSecure client; client.setInsecure();
  HTTPClient https;
  https.setTimeout(8000);
  https.setFollowRedirects(HTTPC_FORCE_FOLLOW_REDIRECTS);

  String base = String(SCRIPT_URL) + "?k=" + SHEET_SECRET + "&ct=pull_state";

  auto tryOnce = [&](const String& url)->bool{
    Serial.println(String("[SheetPull] GET ")+url);
    if (!https.begin(client, url)) return false;
    int code = https.GET();
    String body = https.getString();
    https.end();

    if (code != 200 || body.length()==0) {
      Serial.printf("[SheetPull] HTTP %d body=%s\n", code, body.c_str());
      return false;
    }
    if (body.indexOf("\"ok\":true") < 0) {
      Serial.printf("[SheetPull] not ok: %s\n", body.c_str());
      return false;
    }

    auto findNum = [&](const char* key, double& out)->bool{
      String k = String("\"")+key+"\":";
      int p = body.indexOf(k); if (p<0) return false;
      p += k.length();
      while (p<(int)body.length() && (body[p]==' '||body[p]=='\t')) p++;
      int q=p;
      while (q<(int)body.length() && (isdigit(body[q])||body[q]=='-'||body[q]=='+'||body[q]=='.'||body[q]=='e'||body[q]=='E')) q++;
      out = atof(body.substring(p,q).c_str());
      return true;
    };

    double dWh=0,wWh=0,mWh=0, dWhPrev=0,wWhPrev=0,mWhPrev=0;
    bool ok1=findNum("dWh", dWh);
    bool ok2=findNum("wWh", wWh);
    bool ok3=findNum("mWh", mWh);
    bool ok4=findNum("dWhPrev", dWhPrev);
    bool ok5=findNum("wWhPrev", wWhPrev);
    bool ok6=findNum("mWhPrev", mWhPrev);
    if (!(ok1 && ok2 && ok3)) {
      Serial.printf("[SheetPull] missing fields (d=%d w=%d m=%d)\n", ok1, ok2, ok3);
      return false;
    }

    bool updated=false;
    if (dWh > g_dailyWh)  { g_dailyWh  = dWh;  updated=true; }
    if (wWh > g_weeklyWh) { g_weeklyWh = wWh;  updated=true; }
    if (mWh > g_monthWh)  { g_monthWh  = mWh;  updated=true; }

    g_dailyWhPrev  = dWhPrev;
    g_weeklyWhPrev = wWhPrev;
    g_monthWhPrev  = mWhPrev;

    dailyWh      = roundf(g_dailyWh*100.0f)/100.0f;
    weeklyWh     = roundf(g_weeklyWh*100.0f)/100.0f;
    monthWh      = roundf(g_monthWh*100.0f)/100.0f;
    dailyWhPrev  = roundf(g_dailyWhPrev*100.0f)/100.0f;
    weeklyWhPrev = roundf(g_weeklyWhPrev*100.0f)/100.0f;
    monthWhPrev  = roundf(g_monthWhPrev*100.0f)/100.0f;
    monthPct     = (monthWhPrev>0.0f)?((monthWh-monthWhPrev)/monthWhPrev)*100.0f:0.0f;

    dailyWh_str      = withUnit(dailyWh,      2, "Wh");
    weeklyWh_str     = withUnit(weeklyWh,     2, "Wh");
    monthWh_str      = withUnit(monthWh,      2, "Wh");

    dailyWhPrev_str  = withUnit(dailyWhPrev,  2, "Wh");
    weeklyWhPrev_str = withUnit(weeklyWhPrev, 2, "Wh");
    monthWhPrev_str  = withUnit(monthWhPrev,  2, "Wh");

    ArduinoCloud.update();

    // --- รักษากฎ month>=day หลังดึงจากชีต
    if (seedMonthFromDailyOnly()) {
      ArduinoCloud.update();
      persistEnergyIfNeeded();
    }

    Serial.printf("[SheetPull] OK d=%.2f w=%.2f m=%.2f (prev d=%.2f w=%.2f m=%.2f)\n",
                  (float)dailyWh,(float)weeklyWh,(float)monthWh,
                  (float)dailyWhPrev,(float)weeklyWhPrev,(float)monthWhPrev);

    if (updated) persistEnergyIfNeeded();
    return true;
  };

  if (tryOnce(base)) return true;
  return tryOnce(String(SCRIPT_URL)+"?k="+SHEET_SECRET+"&ct=last");
}

/* ==== setup ==== */
/** เริ่มระบบทั้งหมด: Serial, โหลดพลังงาน, เริ่ม Cloud, ตั้ง NTP/RTC, ตั้งขา/ADC/DHT/I2C, วัด offset/baseline, โหลด timers */
void setup(){
  Serial.begin(115200);
  delay(1500);
  Serial.println("[BOOT] Smart Plug]");
  g_bootMs = millis();  // บันทึกเวลาเริ่มบูต

  loadEnergyStateAtBoot();

  initProperties();
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  configTzTime("UTC0","pool.ntp.org","time.google.com","time.nist.gov");
  for (int i=0;i<30;i++){ time_t t=time(nullptr); if (t>1700000000){ ntpOK=true; break; } delay(100); }

  pinMode(RELAY_A_PIN, OUTPUT); pinMode(RELAY_B_PIN, OUTPUT);
  digitalWrite(RELAY_A_PIN, relayA ? RELAY_ON : RELAY_OFF);
  digitalWrite(RELAY_B_PIN, relayB ? RELAY_ON : RELAY_OFF);

  analogReadResolution(12);
  analogSetPinAttenuation(ADC_V_A,  ADC_11db);
  analogSetPinAttenuation(ADC_V_B,  ADC_11db);
  analogSetPinAttenuation(ADC_V_ALL,ADC_11db);
  analogSetPinAttenuation(ADC_I_A,  ADC_11db);
  analogSetPinAttenuation(ADC_I_B,  ADC_11db);

  dht.begin();

  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(100000);

  if (rtc.begin()){
    rtcOK = true;
    if (ntpOK){ rtc.adjust(DateTime((uint32_t)time(nullptr))); Serial.println("[RTC] Sync from NTP."); }
    else if (rtc.lostPower()){ rtc.adjust(DateTime(compileUTC())); Serial.println("[RTC] Lost power - set UTC from compile time."); }
  }else{
    rtcOK = false; Serial.println("[RTC] DS3231 not found; using uptime/NTP.");
  }

  vA_offsetV  = measureOffsetV(ADC_V_A);
  vB_offsetV  = measureOffsetV(ADC_V_B);
  vALL_offsetV= measureOffsetV(ADC_V_ALL);

  iA_base_norm = measureCurrentBaseNorm(ADC_I_A);
  iB_base_norm = measureCurrentBaseNorm(ADC_I_B);
  Serial.printf("[BASE] iA_base_norm=%.6f  iB_base_norm=%.6f\n", iA_base_norm, iB_base_norm);

  Serial.printf("[ADC off] vA=%.3fV vB=%.3fV vALL=%.3fV\n", vA_offsetV, vB_offsetV, vALL_offsetV);

  loadTimers();
  setupSmoothers();
  statusNow = "พร้อมใช้งาน";

  DateTime loc(nowUtc() + TZ_OFFSET_SEC);
  lastResetY = loc.year(); lastResetM = loc.month(); lastResetD = loc.day();
}

/* ===== Debounce mains/voltage display ===== */
/** จัดการกรณีช่องย่อย “แรงดันลอย” แต่เมนยังมีไฟ → ใช้ค่า ALL แทนชั่วคราวเพื่อคำนวณกำลังให้สมจริง */
const float MAINS_VALID_MIN     = 180.0f;
const float CH_FLOATING_MAX_ON  =  60.0f;
const float CH_FLOATING_EXIT    =  80.0f;
const unsigned long SUB_IN_DELAY_MS = 1000;

bool useAllForA = false;
bool useAllForB = false;
unsigned long useAllA_since = 0, useAllB_since = 0;

/* ==== loop: วงจรหลัก ==== */
void loop(){
  ArduinoCloud.update();
  unsigned long nowMs = millis();
  uint32_t now_utc = nowUtc();

  // ===== ดึงจาก Google Sheet หนึ่งครั้งหลังบูต (ดีเลย์ ~5s) =====
  if (!g_sheetPullTried) {
    if (WiFi.status() == WL_CONNECTED && (nowMs - g_bootMs) > 5000UL) {
      g_sheetPullTried = true;
      bool ok = pullLatestFromSheet();
      g_sheetPullDone = ok;
      if (ok) {
        persistEnergyIfNeeded();
      } else {
        Serial.println("[SheetPull] skip (NO_DATA or parse fail)");
      }
    }
  }

  // ป้องกัน Cloud เขียนทับศูนย์เมื่อเพิ่งเชื่อมครั้งแรก → ย้ำค่ากู้คืนกลับเข้า Cloud หนึ่งครั้ง
  static bool reappliedAfterCloud = false;
  if (ArduinoCloud.connected() && !reappliedAfterCloud) {
    dailyWh  = roundf(g_dailyWh*100.0f)/100.0f;
    weeklyWh = roundf(g_weeklyWh*100.0f)/100.0f;
    dailyWhPrev  = roundf(g_dailyWhPrev*100.0f)/100.0f;
    weeklyWhPrev = roundf(g_weeklyWhPrev*100.0f)/100.0f;

    // sync ค่ารายเดือนเข้าคลาวด์ครั้งแรกเหมือนกัน
    monthWh     = roundf(g_monthWh*100.0f)/100.0f;
    monthWhPrev = roundf(g_monthWhPrev*100.0f)/100.0f;
    monthPct    = (monthWhPrev > 0.0f) ? ((monthWh - monthWhPrev)/monthWhPrev)*100.0f : 0.0f;

    // สตริงสำหรับแดชบอร์ด
    dailyWh_str      = withUnit(dailyWh,      2, "Wh");
    weeklyWh_str     = withUnit(weeklyWh,     2, "Wh");
    dailyWhPrev_str  = withUnit(dailyWhPrev,  2, "Wh");
    weeklyWhPrev_str = withUnit(weeklyWhPrev, 2, "Wh");
    monthWh_str      = withUnit((float)g_monthWh,     2, "Wh");
    monthWhPrev_str  = withUnit((float)g_monthWhPrev, 2, "Wh");

    ArduinoCloud.update();
    reappliedAfterCloud = true;
    Serial.println("[NVS] re-applied restored energy after cloud sync.");
  }

  // อ่าน DHT ประมาณทุก 2 วินาที + EMA ให้ตัวเลขสวย
  static unsigned long lastDHT=0;
  if(nowMs - lastDHT >= 2000){
    float h=dht.readHumidity(), t=dht.readTemperature();
    if(!isnan(h)&&!isnan(t)){
      humidity=round1(ema_hum.filt(h));
      tempC=round1(ema_temp.filt(t));
      tempC_str    = withUnit(tempC,    1, "°C");
      humidity_str = withUnit(humidity, 1, "%");
    }
    lastDHT=nowMs;
  }

  /* ===== สะสม ADC เพื่อคำนวณค่า 1 วินาที ===== */
  float vVA   = adcToVolt(readADConce(ADC_V_A))   - vA_offsetV;
  float vVB   = adcToVolt(readADConce(ADC_V_B))   - vB_offsetV;
  float vVALL = adcToVolt(readADConce(ADC_V_ALL)) - vALL_offsetV;
  vA_r.push(vVA); vB_r.push(vVB); vALL_r.push(vVALL);

  int rIA = readADConce(ADC_I_A);
  int rIB = readADConce(ADC_I_B);
  iA_cnt.push(rIA); iB_cnt.push(rIB);

  float instIA = iA_ctr.abs_dev_norm(rIA) * I_SCALE_A;
  float instIB = iB_ctr.abs_dev_norm(rIB) * I_SCALE_B;

  if(nowMs - last1s >= 1000){
    rtcISO = String("ok:") + (ntpOK? "ntp" : (rtcOK? "rtc-utc":"uptime-utc"));

    // คำนวณ Vrms ของแต่ละช่อง
    float VrmsA  = vA_r.rms()*vA_scaleV_perV;
    float VrmsB  = vB_r.rms()*vB_scaleV_perV;
    float VrmsALL= vALL_r.rms()*vALL_scaleV_perV;

    // คำนวณสถิติ normalized ของกระแส (ดิบ)
    float normA_meas = iA_cnt.std_norm();
    float normB_meas = iB_cnt.std_norm();

    // ตัดฐาน (baseline) เพื่อได้สัญญาณกระแสจริง
    float normA_eff = 0.0f, normB_eff = 0.0f;
    if (normA_meas > iA_base_norm + BASE_MARGIN){
      float sq = normA_meas*normA_meas - iA_base_norm*iA_base_norm;
      if (sq > 0) normA_eff = sqrtf(sq);
    }
    if (normB_meas > iB_base_norm + BASE_MARGIN){
      float sq = normB_meas*normB_meas - iB_base_norm*iB_base_norm;
      if (sq > 0) normB_eff = sqrtf(sq);
    }
    
    float IrmsA = normA_eff * I_SCALE_A;
    float IrmsB = normB_eff * I_SCALE_B;

    // แสดงผลกระแสตัด bias + EMA
    float dispA = IrmsA - DISP_BIAS_A; if (dispA < 0) dispA = 0;
    float dispB = IrmsB - DISP_BIAS_B; if (dispB < 0) dispB = 0;

    currentA   = zfloor(round2( ema_iA.filt(dispA) ), 0.01f);
    currentB   = zfloor(round2( ema_iB.filt(dispB) ), 0.01f);

    // เรียนรู้ baseline เมื่อ “เงียบพอ” ต่อเนื่อง
    bool quietA = (!relayA) || (dispA < 0.03f);
    bool quietB = (!relayB) || (dispB < 0.03f);
    if (quietA){
      if(!capSinceA) capSinceA=nowMs;
      if (nowMs - capSinceA > BASE_HOLD_MS){
        iA_base_norm = (1.0f-BASE_ALPHA)*iA_base_norm + BASE_ALPHA*normA_meas;
      }
    }else capSinceA=0;
    if (quietB){
      if(!capSinceB) capSinceB=nowMs;
      if (nowMs - capSinceB > BASE_HOLD_MS){
        iB_base_norm = (1.0f-BASE_ALPHA)*iB_base_norm + BASE_ALPHA*normB_meas;
      }
    }else capSinceB=0;

    // ตรรกะเลือกใช้แรงดัน ALL แทนช่องที่ลอย
    bool Aon = relayA;
    bool Bon = relayB;

    if (Aon){
      if (!useAllForA){
        if (VrmsA < CH_FLOATING_MAX_ON && VrmsALL > MAINS_VALID_MIN){
          useAllForA = true; 
          useAllA_since = nowMs;
        }
      }else{
        if (VrmsA > CH_FLOATING_EXIT){
          useAllForA = false; 
          useAllA_since = 0;
        }
      }
    }else{
      useAllForA=false; 
      useAllA_since=0;
    }

    if (Bon){
      if (!useAllForB){
        if (VrmsB < CH_FLOATING_MAX_ON && VrmsALL > MAINS_VALID_MIN){
          useAllForB = true; 
          useAllB_since = nowMs;
        }
      }else{
        if (VrmsB > CH_FLOATING_EXIT){
          useAllForB = false; 
          useAllB_since = 0;
        }
      }
    }else{
      useAllForB=false; 
      useAllB_since=0;
    }

    bool onlyAon = (Aon && !Bon);
    bool onlyBon = (Bon && !Aon);
    bool allowUseAllA = useAllForA && onlyAon && (nowMs - useAllA_since >= SUB_IN_DELAY_MS);
    bool allowUseAllB = useAllForB && onlyBon && (nowMs - useAllB_since >= SUB_IN_DELAY_MS);

    float vA_show = Aon ? (allowUseAllA ? VrmsALL : VrmsA) : 0.0f;
    float vB_show = Bon ? (allowUseAllB ? VrmsALL : VrmsB) : 0.0f;

    voltageA   = round1( smoothVoltDB(svA,   vA_show) );
    voltageB   = round1( smoothVoltDB(svB,   vB_show) );
    voltageAll = round1( smoothVoltDB(svAll, VrmsALL) );

    float iAll_sum = (Aon ? currentA : 0.0f) + (Bon ? currentB : 0.0f);
    currentAll = zfloor(round2( ema_iALL.filt(iAll_sum) ), 0.01f);

    float pA = Aon ? (vA_show * dispA) : 0.0f;
    float pB = Bon ? (vB_show * dispB) : 0.0f;

    powerA = round2( ema_pA.filt(pA) );
    powerB = round2( ema_pB.filt(pB) );

    float powerTotal = 0.0f;
    if (Aon) powerTotal += powerA;
    if (Bon) powerTotal += powerB;
    if (powerTotal < 0) powerTotal = 0;

    // พลังงานรวม real-time (Wh) = W * (1/3600) ต่อวินาที
    energyWh += powerTotal * (1.0f/3600.0f);

    // ==== อัปเดตพลังงานสะสมวัน/สัปดาห์/เดือน และตรวจเวลา “ตัดรอบ” ====
    {
      const double dWhInc = powerTotal * (1.0/3600.0);
      g_dailyWh  += dWhInc;
      g_weeklyWh += dWhInc;
      g_monthWh  += dWhInc;

      DateTime loc(nowUtc() + TZ_OFFSET_SEC);

      if (loc.year()!=lastResetY || loc.month()!=lastResetM || loc.day()!=lastResetD){
        didResetToday = false;
      }

      // Log นาทีตัดรอบ
      if (loc.minute()==RESET_MIN && loc.hour()==RESET_HOUR) {
        Serial.printf("[CUTOFF] %04d-%02d-%02d %02d:%02d dowSun0=%d (want=%d) dom=%d\n",
          loc.year(), loc.month(), loc.day(), loc.hour(), loc.minute(),
          dowSun0_local(), WEEKLY_DOW, MONTHLY_DOM);
      }

      if (!didResetToday && loc.hour()==RESET_HOUR && loc.minute()==RESET_MIN){
        // ปิดรอบ “วัน”
        g_dailyWhPrev = g_dailyWh; g_dailyWh = 0.0;
        if (g_dailyWhPrev < 0) g_dailyWhPrev = 0;
        String ds = "ใช้ไฟวันนี้: " + String((float)round2(g_dailyWhPrev), 2) + " Wh";
        ds += " | แนะนำ: " + getTip();
        dailySummary = ds;

        // ดันเข้า hist7
        int todayYmd = loc.year()*10000 + loc.month()*100 + loc.day();
        hist7_push((float)g_dailyWhPrev, todayYmd);

        // ปิดรอบ/ประกาศสัปดาห์ (ถ้าตรงวัน)
        if (dowSun0_local() == WEEKLY_DOW) {
          int keyNow = makeYmdHM(loc);
          if (!weeklyRolledToday) {
            sendWeeklySummary(/*doRollover=*/true);
            lastWeeklySentKey = keyNow;
          } else {
            sendWeeklySummary(/*doRollover=*/false);
            lastWeeklySentKey = keyNow;
          }
        }

        // ปิดรอบ/ประกาศเดือน (ถ้าตรงวันที่) — ใช้เวลาเดียวกับ daily cutoff
        if (isMonthlyCutoffToday(loc)) {
          int keyNowM = makeYmdHM(loc);
          if (!monthlyRolledThisMonth) {
            sendMonthlySummary(/*doRollover=*/true);
            lastMonthlySentKey = keyNowM;
          } else {
            sendMonthlySummary(/*doRollover=*/false);
            lastMonthlySentKey = keyNowM;
          }
        }

        didResetToday = true;
        lastResetY = loc.year(); lastResetM = loc.month(); lastResetD = loc.day();
        needImmediatePost = true;

        persistEnergyIfNeeded();
        g_justDailyReset = true;
        g_clearAdviceAfterPost = true;
        Serial.println("[ENERGY] closed daily (weekly/monthly check).");
      }

      // อัปเดตตัวแปรคลาวด์สำหรับแดชบอร์ด
      dailyWh      = roundf(g_dailyWh      *100.0f)/100.0f;
      weeklyWh     = roundf(g_weeklyWh     *100.0f)/100.0f;
      dailyWhPrev  = roundf(g_dailyWhPrev  *100.0f)/100.0f;
      weeklyWhPrev = roundf(g_weeklyWhPrev *100.0f)/100.0f;

      // รายเดือน (float + string + %)
      monthWh      = roundf(g_monthWh*100.0f)/100.0f;
      monthWhPrev  = roundf(g_monthWhPrev*100.0f)/100.0f;
      monthPct     = (monthWhPrev > 0.0f) ? ((monthWh - monthWhPrev)/monthWhPrev)*100.0f : 0.0f;
    }
    // ==== end energy updates ====

    // บันทึก NVS เมื่อถึงเวลา/เปลี่ยนเยอะพอ
    persistEnergyIfNeeded();

    // Debug แสดงค่าปัจจุบัน
    Serial.printf("[DBG] IA=%.3fA IB=%.3fA ALL=%.3fA vA=%.1f vB=%.1f vALL=%.1f P=%.2fW\n",
                  currentA, currentB, currentAll, voltageA, voltageB, voltageAll, powerTotal);

    // อัปเดตสตริงแสดงผลต่าง ๆ
    currentAll_str = withUnit(currentAll, 2, "A");
    currentA_str   = withUnit(currentA,   2, "A");
    currentB_str   = withUnit(currentB,   2, "A");

    voltageAll_str = withUnit(voltageAll, 2, "V");
    voltageA_str   = withUnit(voltageA, 2, "V");
    voltageB_str   = withUnit(voltageB, 2, "V");

    powerA_str     = withUnit(powerA,     2, "W");
    powerB_str     = withUnit(powerB,     2, "W");
    powerAll_str   = withUnit(powerTotal, 2, "W");

    // สตริงสำหรับแดชบอร์ด (วัน/สัปดาห์/เดือน)
    dailyWh_str      = withUnit(dailyWh,      2, "Wh");
    weeklyWh_str     = withUnit(weeklyWh,     2, "Wh");
    dailyWhPrev_str  = withUnit(dailyWhPrev,  2, "Wh");
    weeklyWhPrev_str = withUnit(weeklyWhPrev, 2, "Wh");
    monthWh_str      = withUnit((float)g_monthWh,     2, "Wh");
    monthWhPrev_str  = withUnit((float)g_monthWhPrev, 2, "Wh");

    // เคลียร์ตัวสะสม 1 วินาที
    vA_r.reset(); vB_r.reset(); vALL_r.reset();
    iA_cnt.reset(); iB_cnt.reset();
    sumW_A=0; sumW_B=0; nW_A=0; nW_B=0; last1s=nowMs;

    if (!Aon && currentA != 0.0f) currentA = 0.0f;
    if (!Bon && currentB != 0.0f) currentB = 0.0f;

    updateStatusNow();

    // --- Weekly announce helper: กันส่งซ้ำภายในนาทีเดียวกัน ---
    {
      DateTime loc(nowUtc() + TZ_OFFSET_SEC);
      static int lastYmd_forWeekly = makeYmd(loc);
      int ymdNow = makeYmd(loc);
      if (ymdNow != lastYmd_forWeekly) {
        weeklyRolledToday = false;
        lastWeeklySentKey = 0;
        lastYmd_forWeekly = ymdNow;
      }
      if (dowSun0_local() == WEEKLY_DOW &&
          loc.hour() == RESET_HOUR && loc.minute() == RESET_MIN) {
        int key = makeYmdHM(loc);
        if (key != lastWeeklySentKey) {
          sendWeeklySummary(/*doRollover=*/false);
          lastWeeklySentKey = key;
        }
      }
    }
    // --- Monthly announce helper: กันส่งซ้ำ และรีเซ็ต state เมื่อเปลี่ยนเดือน ---
    {
      DateTime loc(nowUtc() + TZ_OFFSET_SEC);
      static int lastYm_forMonthly = loc.year()*100 + loc.month(); // yyyymm
      int ymNow = loc.year()*100 + loc.month();
      if (ymNow != lastYm_forMonthly) {
        monthlyRolledThisMonth = false;
        lastMonthlySentKey = 0;
        allowMonthSeed = true;  // เดือนใหม่เปิดให้ seed ได้อีกครั้งจนกว่าจะตัดรอบ
        lastYm_forMonthly = ymNow;
      }
      if (isMonthlyCutoffToday(loc) &&
          loc.hour() == RESET_HOUR && loc.minute() == RESET_MIN) {
        int key = makeYmdHM(loc);
        if (key != lastMonthlySentKey) {
          sendMonthlySummary(/*doRollover=*/false);
          lastMonthlySentKey = key;
        }
      }
    }
  }

  /* ===== Overcurrent ===== */
  /** ตรวจจับกระแสเกินแบบทันที + เวลาถือ → ตัดรีเลย์และส่ง Alert */
  float instIA_adj = max(0.0f, iA_ctr.abs_dev_norm(analogRead(ADC_I_A))*I_SCALE_A - DISP_BIAS_A);
  float instIB_adj = max(0.0f, iB_ctr.abs_dev_norm(analogRead(ADC_I_B))*I_SCALE_B - DISP_BIAS_B);

  bool overA = (currentA > LIMIT_A + LIMIT_MARGIN) || (instIA_adj > LIMIT_A + LIMIT_MARGIN);
  bool overB = (currentB > LIMIT_B + LIMIT_MARGIN) || (instIB_adj > LIMIT_B + LIMIT_MARGIN);

  bool trippedA = false, trippedB = false;

  if (relayA && !latchedA){
    if (overA){
      if (aOverStart==0) aOverStart=nowMs;
      if (nowMs - aOverStart >= TRIP_HOLD_MS){
        relayA=false; onRelayAChange(); latchedA=true; aOverStart=0;
        trippedA=true;
      }
    }else aOverStart=0;
  }
  if (relayB && !latchedB){
    if (overB){
      if (bOverStart==0) bOverStart=nowMs;
      if (nowMs - bOverStart >= TRIP_HOLD_MS){
        relayB=false; onRelayBChange(); latchedB=true; bOverStart=0;
        trippedB=true;
      }
    }else bOverStart=0;
  }

  if (trippedA || trippedB){
    if (trippedA && trippedB){
      float limMax = (LIMIT_A > LIMIT_B) ? LIMIT_A : LIMIT_B;
      setAlertMessage("plugA and plugB กระแสเกิน(" + fmt2(limMax) + "A) ตัดโหลดแล้ว");
      addAdvice("พบกระแสเกินทั้ง A และ B — ตัดโหลดอัตโนมัติ");
      tripA_flag = true; tripB_flag = true; needImmediatePost = true;
    }else if (trippedA){
      setAlertMessage("plugA กระแสเกิน(" + fmt2(LIMIT_A) + "A) ตัดโหลดแล้ว");
      addAdvice("ปลั๊ก A กระแสเกิน — ตัดโหลดอัตโนมัติ");
      tripA_flag = true; needImmediatePost = true;
    }else{
      setAlertMessage("ปลั๊ก B กระแสเกิน(" + fmt2(LIMIT_B) + "A) ตัดโหลดแล้ว");
      addAdvice("ปลั๊ก B กระแสเกิน — ตัดโหลดอัตโนมัติ");
      tripB_flag = true; needImmediatePost = true;
    }
  }else{
    if (millis() >= g_alertLockUntilMs) {
      setAlertMessage("Plug A: ทำงานปกติ  |  Plug B: ทำงานปกติ");
    }
  }

  /* ===== Timers ===== */
  /** ทำงานคำสั่งนัดเมื่อถึงเวลา แล้วเคลียร์นัด + อัปเดตสถานะ */
  if (due(A_onAt_s,now_utc)) { A_onAt_s=0; saveTimers(); relayA=true;  onRelayAChange();  showNextA=false; Serial.println("[Timer] A -> ON"); }
  if (due(A_offAt_s,now_utc)){ A_offAt_s=0; saveTimers(); relayA=false; onRelayAChange();  showNextA=false; Serial.println("[Timer] A -> OFF"); }
  if (due(B_onAt_s,now_utc)) { B_onAt_s=0; saveTimers(); relayB=true;  onRelayBChange();  showNextB=false; Serial.println("[Timer] B -> ON"); }
  if (due(B_offAt_s,now_utc)){ B_offAt_s=0; saveTimers(); relayB=false; onRelayBChange();  showNextB=false; Serial.println("[Timer] B -> OFF"); }

  if (A_onAt_s==0 && A_offAt_s==0 && B_onAt_s==0 && B_offAt_s==0){
    showNextAll = false; showOnlyAll = false;
  }

  // ตรวจ NTP เป็นระยะ และ sync RTC หากเหลื่อม
  static unsigned long lastNtpCheck=0;
  if (millis() - lastNtpCheck > 30000UL) {
    time_t t = time(nullptr);
    if (t > 1700000000) {
      if (!ntpOK) Serial.println("[NTP] acquired.");
      ntpOK = true;
      if (rtcOK) {
        uint32_t rtcNow = rtc.now().unixtime();
        if (labs((long)rtcNow - (long)t) > 2) {
          rtc.adjust(DateTime((uint32_t)t));
          Serial.println("[RTC] re-sync from NTP.");
        }
      }
    }
    lastNtpCheck = millis();
  }

  // ส่งข้อมูลขึ้นชีต: ทันทีหรือครบรอบเวลา
  if (needImmediatePost || (millis() - lastPostMs >= POST_INTERVAL_MS)) {
    needImmediatePost = false;
    lastPostMs = millis();
    postToGoogleSheet();
  }
}

/* ==== Cloud callbacks ==== */
/** ยกเลิกตัวจับเวลา A/B/ALL แล้วแจ้งผู้ใช้ */
void cancelTimers(char which){
  if(which=='A'||which=='X'){ A_onAt_s=0; A_offAt_s=0; showNextA=false; }
  if(which=='B'||which=='X'){ B_onAt_s=0; B_offAt_s=0; showNextB=false; }
  if(which=='X'){ showNextAll=false; showOnlyAll=false; }

  saveTimers();
  pushReply(whoStr(which)+" ยกเลิกตัวจับเวลาแล้ว");

  statusNow = "";
  updateStatusNow();
}

void onStandbyAlertChange() { /* no-op */ }

/** onMsgCommandChange: parser คำสั่งหลัก (TH/EN) ครอบคลุม:
 *  - A/B/ALL ON|OFF
 *  - ตั้งเวลาแบบ 30 นาที / 1 ชั่วโมง / 2 ชั่วโมง 30 นาที
 *  - ตั้งแบบ at HH:MM (เวลาท้องถิ่น)
 *  - คำสั่งช่วยเหลือ (help/?), CAL A/B, BIAS, ZERO, CANCEL ฯลฯ
 */
void onMsgCommandChange(){
  if (g_echoing) { Serial.println("[CB] echo skip"); return; }
  String raw = msgCommand;
  Serial.println(String("[CB] onMsgCommandChange raw='")+raw+"' len="+raw.length());

  String all = normalizeSpaces(raw);
  if (all.length()==0){ showSuggestions('?'); return; }

  // ====== คำสั่ง idempotent ตรง ๆ ======
  String u = toUpperAscii(all);

  if (u == "A ON" || all == "A เปิด") {
    if (relayA) pushReply("A → เปิดอยู่แล้ว");
    else { relayA = true; onRelayAChange(); pushReply("A → เปิดแล้ว"); }
    return;
  }
  if (u == "A OFF" || all == "A ปิด") {
    if (!relayA) pushReply("A → ปิดอยู่แล้ว");
    else { relayA = false; onRelayAChange(); pushReply("A → ปิดแล้ว"); }
    return;
  }

  if (u == "B ON" || all == "B เปิด") {
    if (relayB) pushReply("B → เปิดอยู่แล้ว");
    else { relayB = true; onRelayBChange(); pushReply("B → เปิดแล้ว"); }
    return;
  }
  if (u == "B OFF" || all == "B ปิด") {
    if (!relayB) pushReply("B → ปิดอยู่แล้ว");
    else { relayB = false; onRelayBChange(); pushReply("B → ปิดแล้ว"); }
    return;
  }

  if (u == "ALL ON" || all == "ALL เปิด") {
    bool changed=false;
    if (!relayA){ relayA=true; onRelayAChange(); changed=true; }
    if (!relayB){ relayB=true; onRelayBChange(); changed=true; }
    if (changed) pushReply("ALL → เปิดแล้ว (A+B)");
    else         pushReply("ALL → เปิดอยู่แล้ว (A+B)");
    return;
  }
  if (u == "ALL OFF" || all == "ALL ปิด") {
    bool changed=false;
    if (relayA){ relayA=false; onRelayAChange(); changed=true; }
    if (relayB){ relayB=false; onRelayBChange(); changed=true; }
    if (changed) pushReply("ALL → ปิดแล้ว (A+B)");
    else         pushReply("ALL → ปิดอยู่แล้ว (A+B)");
    return;
  }
  // ====== END ======

  if (isAny(all, "CANCEL", "ยกเลิก", nullptr)) { cancelTimers('X'); return; }

  // คำสั่งคาลิเบรตกระแสแบบคร่าว ๆ จากสถิติ ADC — ตั้ง I_SCALE_* ให้พอดีกับ “target A”
  if (all.startsWith("CAL A ")){
    float target = all.substring(6).toFloat();
    double s=0,s2=0; const int N=512;
    for(int i=0;i<N;i++){ int x=analogRead(ADC_I_A); s+=x; s2+=(double)x*(double)x; }
    double m=s/N, v=s2/N - m*m; if(v<0)v=0;
    float norm=(float)(sqrt(v)/ADC_FULL_SCALE);
    if (norm>0.0005f){ I_SCALE_A = target / norm; pushReply(String("[CAL] A: norm=")+String(norm,6)+" -> I_SCALE_A="+String(I_SCALE_A,3)); }
    else pushReply("[CAL] A: norm too small");
    return;
  }
  if (all.startsWith("CAL B ")){
    float target = all.substring(6).toFloat();
    double s=0,s2=0; const int N=512;
    for(int i=0;i<N;i++){ int x=analogRead(ADC_I_B); s+=x; s2+=(double)x*(double)x; }
    double m=s/N, v=s2/N - m*m; if(v<0) v=0;
    float norm=(float)(sqrt(v)/ADC_FULL_SCALE);
    if (norm>0.0005f){ I_SCALE_B = target / norm; pushReply(String("[CAL] B: norm=")+String(norm,6)+" -> I_SCALE_B="+String(I_SCALE_B,3)); }
    else pushReply("[CAL] B: norm too small");
    return;
  }

  // ปรับ bias แสดงผลกระแส
  if (all.startsWith("BIAS A ")){ DISP_BIAS_A = all.substring(7).toFloat(); pushReply(String("[BIAS] A set to ")+String(DISP_BIAS_A,3)+" A"); return; }
  if (all.startsWith("BIAS B ")){ DISP_BIAS_B = all.substring(7).toFloat(); pushReply(String("[BIAS] B set to ")+String(DISP_BIAS_B,3)+" A"); return; }
  if (all.startsWith("BIAS BOTH ")){ float v = all.substring(10).toFloat(); DISP_BIAS_A = DISP_BIAS_B = v; pushReply(String("[BIAS] A & B set to ")+String(v,3)+" A"); return; }

  // ZERO baseline ใหม่
  if (toUpperAscii(all)=="ZERO" || toUpperAscii(all)=="FORCE ZERO"){
    iA_base_norm = measureCurrentBaseNorm(ADC_I_A);
    iB_base_norm = measureCurrentBaseNorm(ADC_I_B);
    pushReply(String("[ZERO] iA_base_norm=")+String(iA_base_norm,6)+"  iB_base_norm="+String(iB_base_norm,6));
    return;
  }

  if (toUpperAscii(all)=="HELP" || all=="?"){ showSuggestions('?'); return; }

  // รองรับคำสั่งหลายส่วนคั่นด้วย comma
  int start=0; bool anyOK=false;
  while (start < (int)all.length()){
    int comma = all.indexOf(',', start);
    String part = (comma>=0)? all.substring(start, comma) : all.substring(start);
    part.trim();
    start = (comma>=0)? comma+1 : all.length();
    if (part.length()==0) continue;

    String who, act, tail;
    split3Tokens(part, who, act, tail);

    if (act.length()==0 || act=="?" || act=="？"){
      if (isAny(who,"A",nullptr,nullptr)) showSuggestions('A');
      else if (isAny(who,"B",nullptr,nullptr)) showSuggestions('B');
      else if (isAny(who,"ALL","ทั้งหมด",nullptr)) showSuggestions('X');
      else showSuggestions('?');
      anyOK=true;
      continue;
    }

    char which=0;
    if (isAny(who,"A",nullptr,nullptr)) which='A';
    else if (isAny(who,"B",nullptr,nullptr)) which='B';
    else if (isAny(who,"ALL","ทั้งหมด",nullptr)) which='X';
    else { Serial.println("[Msg] Skip (WHO?): "+part); continue; }

    bool isCancel=false, turnOn=false;
    if (isAny(act,"ON","OPEN","เปิด")) turnOn=true;
    else if (isAny(act,"OFF","CLOSE","ปิด")) turnOn=false;
    else if (isAny(act,"CANCEL","ยกเลิก",nullptr)) isCancel=true;
    else { Serial.println("[Msg] Skip (ACTION?): "+part); continue; }

    bool handledAbs=false;
    if (tail.length()>0){
      int _h,_m;
      if (hasAtKeyword(tail) || findHHMM(tail, _h, _m)){
        uint32_t whenUTC = parseLocalHHMM_toUTC(tail);
        if (whenUTC != 0){
          scheduleActionAt(which?which:'X', turnOn, whenUTC);
          anyOK=true;
          handledAbs=true;
        }
      }
    }
    if (handledAbs) continue;

    int mins = parseDurationToMinutes(tail);
    scheduleAction(which?which:'X', turnOn, mins);
    anyOK=true;
  }

  if (!anyOK) showSuggestions('?');
}

/** onRelayAChange/onRelayBChange: เขียนขารีเลย์จริง และปลด latch หากเปิดใหม่ */
void onRelayAChange(){ if (relayA) latchedA=false; digitalWrite(RELAY_A_PIN, relayA?RELAY_ON:RELAY_OFF); }
void onRelayBChange(){ if (relayB) latchedB=false; digitalWrite(RELAY_B_PIN, relayB?RELAY_ON:RELAY_OFF); }

/** onResetEnergyChange: เคลียร์ energyWh ตัวรวม (ไม่ยุ่งกับตัวนับรอบ) */
void onResetEnergyChange(){ if (resetEnergy){ energyWh=0.0f; resetEnergy=false; Serial.println("[Cloud] Energy reset."); } }

/* ==== Send to Google Sheet ==== */
/** สร้าง URL และส่งข้อมูลขึ้นชีต:
 *  - แพ็กปกติ (ทุกนาที)
 *  - แพ็กเฉพาะกิจรายวัน/สัปดาห์/เดือน เมื่อมีธง g_just*Reset
 *  - แนบ summary_any เพื่อกันตกหล่น
 */
void postToGoogleSheet(){
  WiFiClientSecure client; client.setInsecure();
  HTTPClient https;
  https.setTimeout(8000);
  https.setFollowRedirects(HTTPC_FORCE_FOLLOW_REDIRECTS);

  auto baseUrl = [&](){
    String url = String(SCRIPT_URL) + "?k=" + SHEET_SECRET
      + "&swA=" + (relayA ? "true":"false")
      + "&swB=" + (relayB ? "true":"false")
      + "&iIn=" + String(currentAll,3)
      + "&vIn=" + String(voltageAll,1)
      + "&vA="  + String(voltageA,1)
      + "&vB="  + String(voltageB,1)
      + "&iA="  + String(currentA,3)
      + "&iB="  + String(currentB,3)
      + "&pA="  + String(powerA,2)
      + "&pB="  + String(powerB,2)
      + "&tC="  + String(tempC,1)
      + "&hum=" + String(humidity,1)
      + "&tripA=" + (tripA_flag ? "true":"false")
      + "&tripB=" + (tripB_flag ? "true":"false")
      + "&dWh="      + String(dailyWh,2)
      + "&wWh="      + String(weeklyWh,2)
      + "&mWh="      + String((float)g_monthWh,2)
      + "&dWhPrev="  + String(dailyWhPrev,2)
      + "&wWhPrev="  + String(weeklyWhPrev,2)
      + "&mWhPrev="  + String((float)g_monthWhPrev,2);
    return url;
  };

  auto doGet = [&](String url){
    if (!https.begin(client, url)) { Serial.println("[Sheet] begin() failed"); return; }
    int code = https.GET();
    String resp = https.getString();
    https.end();
    Serial.printf("[Sheet] GET %d: %s\n", code, resp.c_str());
  };

  bool sent = false;

  // แพ็กสรุปรายสัปดาห์ (เฉพาะกิจ)
  if (g_justWeeklyReset) {
    String u = baseUrl();
    u += "&weeklySummary=" + urlEncode(weeklySummary);
    u += "&ct=weekly";
    doGet(u);
    g_justWeeklyReset = false;
    sent = true;
  }

  // แพ็กสรุปรายเดือน (เฉพาะกิจ)
  if (g_justMonthlyReset) {
    String u = baseUrl();
    u += "&monthlySummary=" + urlEncode(monthlySummary);
    u += "&ct=monthly";
    doGet(u);
    g_justMonthlyReset = false;
    sent = true;
  }

  // แพ็กปกติ/รายวัน
  String url = baseUrl();
  if (g_justDailyReset) {
    url += "&dailySummary="  + urlEncode(dailySummary);
    url += "&adviceSummary=" + urlEncode(gAdviceSummary);
    url += "&ct=summary";
    g_justDailyReset = false;
    g_clearAdviceAfterPost = false;
  }

  // แนบ weekly/monthly summary แบบ any กันตกหล่น
  if (weeklySummary.length() > 0) {
    url += "&weeklySummary_any=" + urlEncode(weeklySummary);
  }
  if (monthlySummary.length() > 0) {
    url += "&monthlySummary_any=" + urlEncode(monthlySummary);
  }

  doGet(url);
  sent = true;

  if (sent) {
    clearAdvice();
    tripA_flag = false;
    tripB_flag = false;
  }
}
void onResetDailyChange() {
  if (resetDaily) {                           // ถ้าผู้ใช้กดรีเซ็ต "รายวัน"
    energyWh = 0.0f;                          // เคลียร์ตัวนับพลังงานรวมแบบเรียลไทม์ (Wh) ของทั้งระบบ
    g_dailyWh = 0.0;     dailyWh = 0.0;       // เคลียร์สะสมรอบวัน ทั้งค่าภายใน (g_dailyWh) และค่าที่โชว์บนคลาวด์ (dailyWh)
    g_dailyWhPrev = 0.0; dailyWhPrev = 0.0;   // เคลียร์ค่ารอบวันก่อนหน้า (เพื่อไม่ให้ไปคำนวณ % เทียบ)
    dailySummary = "ใช้ไฟวันนี้: 0.00 Wh";    // ตั้งข้อความสรุปของวันให้เป็น 0
    needImmediatePost = true;                  // ขอให้ loop() ส่งขึ้น Google Sheet ทันทีรอบถัดไป
    resetDaily = false;                        // เคลียร์สวิตช์คลาวด์กลับเป็น false (ป้องกันทำงานซ้ำ)

    Serial.println("[Cloud] Reset DAILY: cleared."); // ล็อกดีบัก
  }
}

void onResetWeeklyChange() {
  if (resetWeekly) {                          // ถ้าผู้ใช้กดรีเซ็ต "รายสัปดาห์"
    energyWh = 0.0f;                          // เคลียร์พลังงานรวมเรียลไทม์
    g_weeklyWh = 0.0;     weeklyWh = 0.0;     // เคลียร์สะสมรอบสัปดาห์ (ภายใน + โชว์)
    g_weeklyWhPrev = 0.0; weeklyWhPrev = 0.0; // เคลียร์ค่ารอบสัปดาห์ก่อนหน้า
    weeklySummary = "ใช้ไฟสัปดาห์นี้: 0.00 Wh 0% (เริ่มต้น) | แนะนำ: " + getTip(); // ตั้งข้อความสรุปสัปดาห์ และใส่ทิป
    needImmediatePost = true;                  // ขอให้ส่งขึ้นชีททันที
    g_justWeeklyReset = true;                  // ตั้งธงว่ามีการรีเซ็ตสัปดาห์ (ให้ postToGoogleSheet() สร้างแพ็ก ct=weekly)
    weeklyRolledToday = false;                 // รีเซ็ตสถานะ “ตัดรอบสัปดาห์แล้วหรือยัง” สำหรับวันนี้
    lastWeeklySentKey = 0;                     // เคลียร์คีย์กันส่งซ้ำ
    resetWeekly = false;                       // ปิดสวิตช์คลาวด์

    Serial.println("[Cloud] Reset WEEKLY: cleared.");
  }
}

void onResetMonthlyChange() {
  if (resetMonthly) {                          // ถ้าผู้ใช้กดรีเซ็ต "รายเดือน"
    // ไม่แตะ g_monthWhPrev เพื่อเก็บค่าเดือนก่อน  → ไว้ใช้เทียบเปอร์เซ็นต์ที่แดชบอร์ด/ชีท
    g_monthWh = 0.0;     monthWh = 0.0f;       // เคลียร์สะสมรอบเดือน (ภายใน + โชว์)
    monthPct = (monthWhPrev>0.0f)?((monthWh-monthWhPrev)/monthWhPrev)*100.0f:0.0f; // คำนวณ % เทียบเดือนก่อน (ตอนนี้เป็น 0%)

    monthlySummary = "ใช้ไฟเดือนนี้: 0.00 Wh 0% (เริ่มต้น) | แนะนำ: " + getTip(); // ข้อความสรุปเดือน
    needImmediatePost = true;                   // ขอให้ส่งขึ้นชีททันที
    g_justMonthlyReset = true;                  // ตั้งธงให้ postToGoogleSheet() ทำแพ็ก ct=monthly

    monthlyRolledThisMonth = true;              // มาร์กว่าเดือนนี้ถูกรีเซ็ตแล้ว (กันการ roll ซ้ำ)
    lastMonthlySentKey = 0;                     // เคลียร์คีย์กันส่งซ้ำ
    allowMonthSeed = false;                     // กัน “seedMonthFromDailyOnly()” เด้งค่ากลับขึ้นหลังรีเซ็ต
    resetMonthly = false;                       // ปิดสวิตช์คลาวด์

    Serial.println("[Cloud] Reset MONTHLY: cleared (keep previous month).");
  }
}

/**** === Standby Advisor (<10W for >= STBY_REPEAT_MIN min, repeat) === ****/
/* ส่วน “ตัวช่วยเตือนโหลดสแตนด์บาย”
 * เงื่อนไข: หากปลั๊ก A/B เปิดอยู่และกำลังไฟฟ้า (powerA/powerB) < 10W ต่อเนื่องเกินเวลาที่กำหนด
 *            (STBY_REPEAT_MIN นาที) จะส่งข้อความแจ้งเตือนให้ผู้ใช้ช่วยปิดเพื่อลดการสิ้นเปลือง
 * โครงสร้าง: ใช้ FreeRTOS task (ESP32) วิ่งฉากหลัง อ่านพลังงานทุก ~1 วินาที ตรวจครบเงื่อนไขก็ส่งข้อความ
 */
#if defined(ESP32)
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#endif

void setStandbyAlert(const String& s){
  String t = stripDebugTail(s);     // ตัดส่วน tail debug (ถ้ามี) ออกเพื่อให้ข้อความสั้นกระชับ
  standbyAlert = t;                 // อัปเดตตัวแปรคลาวด์ “standbyAlert” เพื่อแสดงที่แดชบอร์ด
  msgReply     = t;                 // ใส่ซ้ำใน msgReply เพื่อให้เห็นในช่องข้อความโต้ตอบ
  needImmediatePost = true;         // ขอให้ส่งขึ้น Google Sheet ทันทีรอบถัดไป
  ArduinoCloud.update();            // ดันสถานะขึ้นคลาวด์ทันที (ให้ผู้ใช้เห็นเร็วขึ้น)
  Serial.println("[Standby] " + t); // ล็อกข้อความ
  addAdvice(t);                     // เก็บเข้า “ถุงคำแนะนำ” เพื่อนำไปแนบในสรุปรายวันด้วย
}

// ตัวแปรสถานะภายในของที่ปรึกษาสตะแนด์บาย
static bool advisedStandbyA = false, advisedStandbyB = false; // (สำรองไว้ หากต้องการกันซ้ำระดับข้อความ)
static unsigned long standbyStartA = 0, standbyStartB = 0;    // เวลาเริ่มเข้าสภาวะกำลังต่ำของแต่ละช่อง

// แปลงเวลา UTC → วันที่ตามท้องถิ่น (YYYYMMDD) เพื่อรีเซ็ต state เมื่อข้ามวัน
static inline int ymd_local_from_utc(uint32_t utc){
  DateTime loc(utc + TZ_OFFSET_SEC);
  return (loc.year()*10000 + loc.month()*100 + loc.day());
}

static void StandbyTask(void*){
  // เกณฑ์และพารามิเตอร์ของ “สแตนด์บาย”
  const float STBY_MAX_W   = 10.0f;                          // กำลังไฟต่ำกว่าค่านี้ถือว่าเข้าข่ายสแตนด์บาย
  const float STBY_EXIT_W  = 12.0f;                          // ถ้ากลับมาสูงกว่าค่านี้ ถือว่าออกจากสแตนด์บาย
  const unsigned long STBY_HOLD_MS = STBY_REPEAT_MIN * 60UL * 1000UL; // เวลาถือต่อเนื่อง (นาที → มิลลิวินาที)

  unsigned long lastTick = millis();                         // ตัวจับรอบ ~1 วินาที
  int lastYmd = ymd_local_from_utc(nowUtc());                // วันที่ท้องถิ่นล่าสุด (กันค้างข้ามวัน)

  for(;;){                                                   // วนลูปตลอดอายุงานของ Task
    vTaskDelay(pdMS_TO_TICKS(200));                          // พัก 200 ms เพื่อไม่ให้กิน CPU เกินไป
    unsigned long nowMs = millis();
    if (nowMs - lastTick < 1000UL) continue;                 // ให้ทำงานจริง ๆ ทุก ~1 วินาที
    lastTick = nowMs;

    // ถ้าข้ามวัน → รีเซ็ตตัวนับเวลาเริ่มสแตนด์บายของทั้งสองช่อง
    int ymd = ymd_local_from_utc(nowUtc());
    if (ymd != lastYmd){ standbyStartA = standbyStartB = 0; lastYmd = ymd; }

    // ตรวจว่า “ปลั๊กเปิดอยู่” และ “กำลัง < STBY_MAX_W” หรือไม่
    bool lowA = relayA && (powerA < STBY_MAX_W);
    bool lowB = relayB && (powerB < STBY_MAX_W);

    // ช่อง A: ถ้าเข้าเงื่อนไขต่ำ → ถ้ายังไม่มีเวลาเริ่ม ก็จด nowMs
    //         ถ้าออกเงื่อนไข (ปลั๊กปิด/กำลังเกิน STBY_EXIT_W) → ล้างเวลาเริ่ม
    if (lowA) { if (!standbyStartA) standbyStartA = nowMs; }
    else if (!relayA || powerA > STBY_EXIT_W) { standbyStartA = 0; }

    // ช่อง B: หลักการเดียวกัน
    if (lowB) { if (!standbyStartB) standbyStartB = nowMs; }
    else if (!relayB || powerB > STBY_EXIT_W) { standbyStartB = 0; }

    // พร้อมแจ้งเตือนหรือยัง? (ต้องมีเวลาเริ่ม และผ่านเวลาถือครบกำหนด)
    bool readyA = standbyStartA && (nowMs - standbyStartA >= STBY_HOLD_MS);
    bool readyB = standbyStartB && (nowMs - standbyStartB >= STBY_HOLD_MS);

    if (readyA && readyB){
      // ทั้ง A และ B เข้าสแตนด์บายครบเวลา → แจ้งรวม
      setStandbyAlert("เตือนสแตนด์บาย: ปลั๊ก A และ B ใช้ไฟต่ำต่อเนื่อง — ลองปิดเพื่อลดการสิ้นเปลือง");
      standbyStartA = standbyStartB = nowMs;   // รีสตาร์ทนับใหม่ เพื่อไม่ให้แจ้งถี่เกินไป
    } else {
      // แจ้งแยกช่องตามความพร้อม
      if (readyA){
        setStandbyAlert("เตือนสแตนด์บาย: ปลั๊ก A ใช้ไฟต่ำต่อเนื่อง — ลองปิดเพื่อลดการสิ้นเปลือง");
        standbyStartA = nowMs;                 // รีสตาร์ทนับใหม่ของ A
      }
      if (readyB){
        setStandbyAlert("เตือนสแตนด์บาย: ปลั๊ก B ใช้ไฟต่ำต่อเนื่อง — ลองปิดเพื่อลดการสิ้นเปลือง");
        standbyStartB = nowMs;                 // รีสตาร์ทนับใหม่ของ B
      }
    }
  }
}

__attribute__((constructor)) static void _startStandbyTask(){
#if defined(ESP32)
  
  xTaskCreatePinnedToCore(StandbyTask, "StandbyTask", 4096, nullptr, 1, nullptr, 1);
#else
  
#endif
}
