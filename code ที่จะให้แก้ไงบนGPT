serial monitor 
#include "thingProperties.h"
#include <Arduino.h>
#include <math.h>
#include <DHT.h>
#include <Wire.h>
#include <RTClib.h>
#include <Preferences.h>
#include <time.h>

/* ==== ส่ง Google Sheet (ใช้ GET) ==== */
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
const char* SCRIPT_URL   = "https://script.google.com/macros/s/AKfycbx9z_d7pARnuMMtig9l54V5C6MldyGrKKmQ76MqW-7N-9NMQYWbUsr2iKnz5yeJaontLA/exec";
const char* SHEET_SECRET = "Smart_Plug";
const unsigned long POST_INTERVAL_MS = 60000UL;
unsigned long lastPostMs = 0;
volatile bool needImmediatePost = false;
static bool tripA_flag = false;
static bool tripB_flag = false;

/* ===== Pin map ===== */
#ifndef D2
#define D2 2
#endif
#ifndef D5
#define D5 5
#endif
#define RELAY_A_PIN D2
#define RELAY_B_PIN D5
#define RELAY_ON  HIGH
#define RELAY_OFF LOW

#define ADC_V_A    A0   // ZMPT A
#define ADC_V_B    A1   // ZMPT B
#define ADC_I_A    A3   // ACS712 A
#define ADC_I_B    A2   // ACS712 B
#define I2C_SDA    A4   // DS3231 SDA
#define I2C_SCL    A5   // DS3231 SCL
#define ADC_I_ALL  A6   // SCT013 All
#define ADC_V_ALL  A7   // ZMPT All

// DHT11
#define DHTPIN   D8
#define DHTTYPE  DHT11
DHT dht(DHTPIN, DHTTYPE);

/* ===== ADC helpers ===== */
const float ADC_REF = 3.3f;
const int   ADC_MAX = 4095;
inline float adcToVolt(int raw){ return (ADC_REF * raw) / ADC_MAX; }
inline int readADConce(int pin){ analogRead(pin); return analogRead(pin); }
float measureOffsetV(uint8_t pin,int n=400){ double s=0; for(int i=0;i<n;i++) s+=adcToVolt(readADConce(pin)); return s/n; }
auto round1=[](float x){ return roundf(x*10.0f)/10.0f; };
auto round2=[](float x){ return roundf(x*100.0f)/100.0f; };
auto zfloor=[](float x,float th){ return (fabsf(x)<th)?0.0f:x; };

/* ===== คาลิเบรต (ปรับได้) =====
   NOTE: ตั้ง scale ให้ตรงรุ่น ACS712
   - 05B → 5.405 A/V
   - 20A → 10.0 A/V
   - 30A → 15.15 A/V
*/
float iA_offsetV=2.50f, iB_offsetV=2.50f, iALL_offsetV=2.50f;
float vA_offsetV=2.50f, vB_offsetV=2.50f, vALL_offsetV=2.50f;

float iA_scaleA_perV=10.0f;     // ← ถ้า 05B ให้เปลี่ยนเป็น 5.405f
float iB_scaleA_perV=10.0f;     // ← ถ้า 05B ให้เปลี่ยนเป็น 5.405f
float iALL_scaleA_perV=10.0f;   // CT (SCT013) ปรับด้วยการคาลิเบรต
float vA_scaleV_perV=221.90f, vB_scaleV_perV=220.94f, vALL_scaleV_perV=223.36f;

/* ===== Overcurrent ===== */
const float LIMIT_A = 10.0f, LIMIT_B = 10.0f, LIMIT_MARGIN = 0.5f;
const unsigned long TRIP_HOLD_MS = 200;
bool latchedA=false, latchedB=false;
unsigned long aOverStart=0, bOverStart=0;

/* ===== RMS ===== */
struct RMS{ double sum=0,sum2=0; uint32_t n=0;
  inline void push(float x){ sum+=x; sum2+= (double)x*x; n++; }
  inline float rms() const { if(!n) return 0; double m=sum/n; double v=sum2/n - m*m; if(v<0) v=0; return sqrt(v); }
  inline void reset(){ sum=0; sum2=0; n=0; }
};
RMS iA_r,iB_r,iALL_r, vA_r,vB_r,vALL_r;

/* ===== EMA ===== */
struct EMA{ float y=0; bool init=false; float alpha=0.2f;
  void setTauSeconds(float tau){ if(tau<=0) alpha=1; else alpha = 1.0f - expf(-1.0f/tau); }
  float filt(float x){ if(!init){ y=x; init=true; } else y = alpha*x + (1-alpha)*y; return y; }
  void reset(){ init=false; }
};
EMA ema_iA,ema_iB,ema_iALL, ema_pA,ema_pB, ema_temp,ema_hum;
void setupSmoothers(){ float TAU=3.0f;
  ema_iA.setTauSeconds(TAU); ema_iB.setTauSeconds(TAU); ema_iALL.setTauSeconds(TAU);
  ema_pA.setTauSeconds(TAU); ema_pB.setTauSeconds(TAU);
  ema_temp.setTauSeconds(5.0f); ema_hum.setTauSeconds(5.0f);
}

/* ===== ระบบ/พลังงาน ===== */
double   sumW_A=0, sumW_B=0;
uint32_t nW_A=0,  nW_B=0;
unsigned long last1s=0;

Preferences prefs;

/* ===== Cloud reply helper ===== */
volatile bool g_echoing=false;
inline void pushReply(const String& s){ msgReply=s; Serial.println("[Reply] "+s);
  g_echoing=true; msgCommand=s; ArduinoCloud.update(); g_echoing=false; }

void setAlertMessage(const String& s){
  static String last;
  if (s != last){
    msgReply = s;
    ocAlert  = s;
    Serial.println("[Alert] " + s);
    last = s;
    needImmediatePost = true;
  }
}
String fmt2(float x){ char b[16]; snprintf(b, sizeof(b), "%.2f", x); return String(b); }

/* ===== RTC / Time ===== */
RTC_DS3231 rtc; bool rtcOK=false, ntpOK=false;
const long TZ_OFFSET_SEC = 7L*3600L;
static inline uint32_t compileUTC(){ DateTime c(F(__DATE__),F(__TIME__)); return c.unixtime(); }
inline uint32_t nowUtc(){ time_t t=time(nullptr); if(ntpOK && t>1700000000) return (uint32_t)t;
  if(rtcOK) return rtc.now().unixtime(); static uint32_t boot=0; if(!boot) boot=compileUTC(); return boot + millis()/1000UL; }

/* ===== time utils (TH) ===== */
String humanDeltaTH_fromSeconds(uint32_t d){ if((int32_t)d<=0) return "เดี๋ยวนี้";
  unsigned long s=d,h=s/3600; s%=3600; unsigned long m=s/60; s%=60; if(s>0)m++;
  if(m>=60){ h+=m/60; m%=60; } String out="อีก "; if(h){ out+=String(h)+" ชั่วโมง"; if(m) out+=" "+String(m)+" นาที"; }
  else if(m) out+=String(m)+" นาที"; else out+="น้อยกว่า 1 นาที"; return out; }
String formatWhenRelativeUTC(uint32_t t){ uint32_t n=nowUtc(); return humanDeltaTH_fromSeconds(t>n?t-n:0); }

/* ===== Timers (UTC) + โหมดโชว์เฉพาะ All ===== */
uint32_t A_onAt_s=0,A_offAt_s=0,B_onAt_s=0,B_offAt_s=0;
bool showNextA=false, showNextB=false, showNextAll=false;
bool showOnlyAll=false;
void saveTimers(){ prefs.begin("timers",false);
  prefs.putUInt("A_on",A_onAt_s); prefs.putUInt("A_off",A_offAt_s);
  prefs.putUInt("B_on",B_onAt_s); prefs.putUInt("B_off",B_offAt_s); prefs.end(); }
void loadTimers(){ prefs.begin("timers",true);
  A_onAt_s=prefs.getUInt("A_on",0); A_offAt_s=prefs.getUInt("A_off",0);
  B_onAt_s=prefs.getUInt("B_on",0); B_offAt_s=prefs.getUInt("B_off",0); prefs.end(); }
inline bool due(uint32_t when_s,uint32_t now_s){ return (when_s!=0)&&((int32_t)(now_s-when_s)>=0); }
int clampMinutes(int m){ if(m<0)return 0; if(m>1440)return 1440; return m; }

/* ===== Parser / Command ===== */
String normalizeSpaces(String s){
  s.trim();
  const char* specials[] = { "\xC2\xA0", "\xE2\x80\x8B", "\xE2\x80\x8C", "\xE2\x80\x8D" };
  for (const char* pat : specials) while (s.indexOf(pat) >= 0) s.replace(pat, " ");
  while (s.indexOf("  ") >= 0) s.replace("  ", " ");
  return s;
}
String toUpperAscii(String s){ for(size_t i=0;i<s.length();++i){ char c=s[i]; if(c>='a'&&c<='z') s[i]=c-32; } return s; }
void split3Tokens(const String& s,String& t1,String& t2,String& t3){ int p1=s.indexOf(' '); if(p1<0){t1=s; t2=t3="";return;}
  t1=s.substring(0,p1); int p2=s.indexOf(' ',p1+1); if(p2<0){t2=s.substring(p1+1); t3=""; return;}
  t2=s.substring(p1+1,p2); t3=s.substring(p2+1); t1.trim(); t2.trim(); t3.trim();}

bool isAny(const String& token,const char* a,const char* b,const char* c){
  String T=toUpperAscii(token);
  if(a){String A=a; if(toUpperAscii(A)==T||token==A) return true;}
  if(b){String B=b; if(toUpperAscii(B)==T||token==B) return true;}
  if(c){String C=c; if(toUpperAscii(C)==T||token==C) return true;}
  return false;
}

String join(const char* a[],int n){ String s; for(int i=0;i<n;i++){ if(i) s+=" | "; s+=a[i]; } return s; }
void showSuggestions(char which){
  if(which=='?'){ const char* root[]={"A ...","B ...","All ...","help"};
    pushReply("Try: "+join(root,4)+"\nตัวอย่าง: A เปิด 2 ชั่วโมง 30 นาที, B ปิด 30 นาที, All on at 21:30"); return; }
  const char* th[]={"เปิด [เวลา]","ปิด [เวลา]","ยกเลิก"}; const char* en[]={"on [time]","off [time]","cancel"};
  String head=(which=='A')?"A":(which=='B')?"B":"All";
  pushReply(head+" → "+join(th,3)+"\nEN: "+head+" "+join(en,3)+"\n[เวลา]= 30 นาที | 1 ชั่วโมง | 2 ชั่วโมง 30 นาที | at 21:30");
}
int extractFirstInt(const String& s){ String d=""; for(size_t i=0;i<s.length();++i){ char c=s[i]; if(c>='0'&&c<='9') d+=c; else if(d.length()) break; } return d.length()? d.toInt():-1; }
bool hasHourUnit(String s){ String u=toUpperAscii(s);
  if(u.indexOf("HR")>=0||u.indexOf("H ")>=0||u.endsWith("H")) return true;
  if(s.indexOf("ชั่วโมง")>=0||s.indexOf("ชม.")>=0) return true; return false; }
bool hasMinuteUnit(String s){ String u=toUpperAscii(s); if(u.indexOf("MIN")>=0 || u=="M" || u.endsWith(" M")) return true; if(s.indexOf("นาที")>=0) return true; return false; }
int parseDurationToMinutes(String s){
  s=normalizeSpaces(s); s.replace("อีก",""); s.trim(); int total=0,pos=0;
  while(pos<(int)s.length()){ while(pos<(int)s.length()&&s[pos]==' ') pos++; if(pos>=(int)s.length()) break;
    int ns=s.indexOf(' ',pos); String token=(ns<0)? s.substring(pos): s.substring(pos,ns); pos=(ns<0)? s.length():ns+1;
    int v=extractFirstInt(token); if(v<0) continue; bool handled=false;
    if(hasHourUnit(token)){ total+=v*60; handled=true; }
    else if(hasMinuteUnit(token)){ total+=v; handled=true; }
    else{ int ns2=s.indexOf(' ',pos); String next=(ns2<0)? s.substring(pos): s.substring(pos,ns2);
      if(next.length()){ if(hasHourUnit(next)){ total+=v*60; handled=true; pos=(ns2<0? s.length(): ns2+1); }
        else if(hasMinuteUnit(next)){ total+=v; handled=true; pos=(ns2<0? s.length(): ns2+1);} } }
    if(!handled) total+=v; }
  return clampMinutes(total);
}
bool hasAtKeyword(String s){
  s=normalizeSpaces(s); String u=toUpperAscii(s);
  if(u.indexOf(" AT ")>=0 || u.startsWith("AT ") || u.endsWith(" AT")) return true;
  if (s.indexOf("เวลา")>=0) return true; return false;
}
bool findHHMM(const String& s,int& hh,int& mm){
  int c=s.indexOf(':'); if(c<0) return false; int l=c-1; while(l>=0 && isDigit(s[l])) l--; l++;
  int r=c+1; while(r<(int)s.length() && isDigit(s[r])) r++; String H=s.substring(l,c), M=s.substring(c+1,r);
  if(H.length()==0||M.length()<1) return false; int h=H.toInt(), m=M.toInt(); if(h<0||h>23||m<0||m>59) return false; hh=h; mm=m; return true;
}
uint32_t parseLocalHHMM_toUTC(const String& tail){
  int hh=-1,mm=-1; if(!findHHMM(tail,hh,mm)) return 0; uint32_t now=nowUtc();
  DateTime nowL(now+TZ_OFFSET_SEC); DateTime tgtL(nowL.year(),nowL.month(),nowL.day(),hh,mm,0);
  uint32_t tgt=tgtL.unixtime()-TZ_OFFSET_SEC; if((int32_t)(tgt-now)<=0) tgt=(tgtL+TimeSpan(1,0,0,0)).unixtime()-TZ_OFFSET_SEC; return tgt;
}

/* ===== Actions / status ===== */
String whoStr(char w){ return String((w=='X')?"ALL":(w=='A'?"A":"B")); }
String actFutureTH(bool on){ return String(on? "จะเปิด":"จะปิด"); }
void scheduleAction(char which,bool turnOn,int minutes){
  minutes=clampMinutes(minutes); uint32_t when=nowUtc() + (uint32_t)minutes*60UL;
  if(which=='A'||which=='X'){ if(turnOn) A_onAt_s=(minutes==0)? nowUtc():when; else A_offAt_s=(minutes==0)? nowUtc():when; }
  if(which=='B'||which=='X'){ if(turnOn) B_onAt_s=(minutes==0)? nowUtc():when; else B_offAt_s=(minutes==0)? nowUtc():when; }
  if(which=='A') showNextA=(minutes>0);
  else if(which=='B') showNextB=(minutes>0);
  else if(which=='X'){ showNextAll=(minutes>0); showNextA=showNextB=false; showOnlyAll=true; }
  saveTimers();
  pushReply(whoStr(which)+" "+actFutureTH(turnOn)+" "+(minutes? formatWhenRelativeUTC(when):"เดี๋ยวนี้"));
}
void scheduleActionAt(char which,bool turnOn,uint32_t when){
  if(which=='A'||which=='X'){ if(turnOn) A_onAt_s=when; else A_offAt_s=when; }
  if(which=='B'||which=='X'){ if(turnOn) B_onAt_s=when; else B_offAt_s=when; }
  if(which=='A') showNextA=(when>nowUtc());
  else if(which=='B') showNextB=(when>nowUtc());
  else if(which=='X'){ showNextAll=(when>nowUtc()); showNextA=showNextB=false; showOnlyAll=true; }
  saveTimers(); pushReply(whoStr(which)+" "+actFutureTH(turnOn)+" "+formatWhenRelativeUTC(when));
}
void cancelTimers(char which){
  if(which=='A'||which=='X'){ A_onAt_s=0; A_offAt_s=0; showNextA=false; }
  if(which=='B'||which=='X'){ B_onAt_s=0; B_offAt_s=0; showNextB=false; }
  if(which=='X'){ showNextAll=false; showOnlyAll=false; }
  saveTimers(); pushReply(whoStr(which)+" ยกเลิกตัวจับเวลาแล้ว");
}
String relStr(uint32_t when){ if(!when) return ""; return formatWhenRelativeUTC(when); }
String nextABText(char w){ uint32_t onT=(w=='A')?A_onAt_s:B_onAt_s, offT=(w=='A')?A_offAt_s:B_offAt_s;
  if(!onT && !offT) return ""; if(onT && (!offT || (int32_t)(onT-offT)<0)) return String("(จะเปิด ")+relStr(onT)+")";
  return String("(จะปิด ")+relStr(offT)+")"; }
String nextALLText(){ uint32_t tmin=0; bool isOn=false; uint32_t ts[4]={A_onAt_s,A_offAt_s,B_onAt_s,B_offAt_s}; bool ton[4]={true,false,true,false};
  for(int i=0;i<4;i++){ if(!ts[i]) continue; if(!tmin || (int32_t)(ts[i]-tmin)<0){ tmin=ts[i]; isOn=ton[i]; } }
  if(!tmin) return ""; return String(isOn? "จะเปิด ":"จะปิด ")+relStr(tmin);
}
void updateStatusNow(){
  if(showOnlyAll){
    String t=nextALLText();
    String line = t.length()? ("All: "+t) : (String("All: ")+((relayA||relayB)?"เปิดใช้งาน":"ปิดใช้งาน"));
    if(statusNow!=line){ statusNow=line; Serial.println(String("[Status] ")+statusNow); }
    return;
  }
  String aState=relayA?"เปิดใช้งาน":"ปิดใช้งาน";
  String bState=relayB?"เปิดใช้งาน":"ปิดใช้งาน";
  String msg="Plug A: "+aState; if(showNextA){ String t=nextABText('A'); if(t.length()) msg+=" "+t; }
  msg+="\nPlug B: "+bState; if(showNextB){ String t=nextABText('B'); if(t.length()) msg+=" "+t; }
  if(showNextAll){ String t=nextALLText(); if(t.length()) msg+="\nAll: "+t; }
  static String last=""; if(msg!=last){ statusNow=msg; last=msg; Serial.println(String("[Status] ")+msg); }
}

/* ==== setup ==== */
void setup(){
  Serial.begin(115200); delay(1500);
  Serial.println("[BOOT] Smart Plug");

  initProperties();
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // NTP UTC
  configTzTime("UTC0","pool.ntp.org","time.google.com","time.nist.gov");
  for (int i=0;i<30;i++){ time_t t=time(nullptr); if (t>1700000000){ ntpOK=true; break; } delay(100); }

  pinMode(RELAY_A_PIN, OUTPUT); pinMode(RELAY_B_PIN, OUTPUT);
  digitalWrite(RELAY_A_PIN, relayA ? RELAY_ON : RELAY_OFF);
  digitalWrite(RELAY_B_PIN, relayB ? RELAY_ON : RELAY_OFF);

  /* ★★ ADC config ★★ */
  analogReadResolution(12);
  analogSetPinAttenuation(ADC_V_A,  ADC_11db);
  analogSetPinAttenuation(ADC_V_B,  ADC_11db);
  analogSetPinAttenuation(ADC_V_ALL,ADC_11db);
  analogSetPinAttenuation(ADC_I_A,  ADC_11db);
  analogSetPinAttenuation(ADC_I_B,  ADC_11db);
  analogSetPinAttenuation(ADC_I_ALL,ADC_11db);

  dht.begin();

  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(100000);

  if (rtc.begin()){
    rtcOK = true;
    if (ntpOK){ rtc.adjust(DateTime((uint32_t)time(nullptr))); Serial.println("[RTC] Sync from NTP."); }
    else if (rtc.lostPower()){ rtc.adjust(DateTime(compileUTC())); Serial.println("[RTC] Lost power - set UTC from compile time."); }
  }else{
    rtcOK = false; Serial.println("[RTC] DS3231 not found; using uptime/NTP.");
  }

  // วัด offset ตอนบูต (ถอดโหลดจะดีที่สุด)
  iA_offsetV = measureOffsetV(ADC_I_A);
  iB_offsetV = measureOffsetV(ADC_I_B);
  iALL_offsetV = measureOffsetV(ADC_I_ALL);
  vA_offsetV = measureOffsetV(ADC_V_A);
  vB_offsetV = measureOffsetV(ADC_V_B);
  vALL_offsetV = measureOffsetV(ADC_V_ALL);

  Serial.printf("[ADC off] iA=%.3fV iB=%.3fV iALL=%.3fV | vA=%.3fV vB=%.3fV vALL=%.3fV\n",
    iA_offsetV,iB_offsetV,iALL_offsetV,vA_offsetV,vB_offsetV,vALL_offsetV);

  loadTimers();
  setupSmoothers();
  statusNow = "พร้อมใช้งาน";
}

/* ===== กันปลายลอย + หน่วงแสดงผล ===== */
const float MAINS_VALID_MIN     = 180.0f;
const float CH_FLOATING_MAX_ON  =  60.0f;
const float CH_FLOATING_EXIT    =  80.0f;
const unsigned long SUB_IN_DELAY_MS = 1000;

bool useAllForA=false, useAllForB=false;
unsigned long useAllA_since=0, useAllB_since=0;

void loop(){
  ArduinoCloud.update();
  unsigned long nowMs = millis();
  uint32_t now_utc = nowUtc();

  // DHT ~2s
  static unsigned long lastDHT=0;
  if(nowMs - lastDHT >= 2000){
    float h=dht.readHumidity(), t=dht.readTemperature();
    if(!isnan(h)&&!isnan(t)){ humidity=round1(ema_hum.filt(h)); tempC=round1(ema_temp.filt(t)); }
    lastDHT=nowMs;
  }

  /* ===== อ่าน ADC สะสม RMS ===== */
  float vVA   = adcToVolt(readADConce(ADC_V_A))   - vA_offsetV;
  float vVB   = adcToVolt(readADConce(ADC_V_B))   - vB_offsetV;
  float vVALL = adcToVolt(readADConce(ADC_V_ALL)) - vALL_offsetV;

  float vIA   = adcToVolt(readADConce(ADC_I_A))   - iA_offsetV;
  float vIB   = adcToVolt(readADConce(ADC_I_B))   - iB_offsetV;
  float vIALL = adcToVolt(readADConce(ADC_I_ALL)) - iALL_offsetV;

  vA_r.push(vVA); vB_r.push(vVB); vALL_r.push(vVALL);
  iA_r.push(vIA); iB_r.push(vIB); iALL_r.push(vIALL);

  // instant สำหรับ OC (จับยอดไว)
  float instIA = fabsf(vIA)*iA_scaleA_perV;
  float instIB = fabsf(vIB)*iB_scaleA_perV;

  if(nowMs - last1s >= 1000){
    rtcISO = String("ok:") + (ntpOK? "ntp" : (rtcOK? "rtc-utc":"uptime-utc"));

    float VrmsA=vA_r.rms()*vA_scaleV_perV;
    float VrmsB=vB_r.rms()*vB_scaleV_perV;
    float VrmsALL=vALL_r.rms()*vALL_scaleV_perV;
    float IrmsA=iA_r.rms()*iA_scaleA_perV;
    float IrmsB=iB_r.rms()*iB_scaleA_perV;
    float IrmsALL=iALL_r.rms()*iALL_scaleA_perV;

    // ★ เดดโซนเล็กลง 0.003A เพื่อเห็นโหลดเล็ก ๆ
    currentA   = zfloor(round2( ema_iA.filt(IrmsA) ), 0.003f);
    currentB   = zfloor(round2( ema_iB.filt(IrmsB) ), 0.003f);
    currentAll = zfloor(round2( ema_iALL.filt(IrmsALL) ), 0.003f);

    /* ===== anti-floating: เลือกแรงดันโชว์ ===== */
    bool Aon = relayA;
    bool Bon = relayB;

    if (Aon){
      if (!useAllForA){
        if (VrmsA < CH_FLOATING_MAX_ON && VrmsALL > MAINS_VALID_MIN){ useAllForA = true; useAllA_since = nowMs; }
      }else{
        if (VrmsA > CH_FLOATING_EXIT){ useAllForA = false; useAllA_since = 0; }
      }
    }else{ useAllForA=false; useAllA_since=0; }

    if (Bon){
      if (!useAllForB){
        if (VrmsB < CH_FLOATING_MAX_ON && VrmsALL > MAINS_VALID_MIN){ useAllForB = true; useAllB_since = nowMs; }
      }else{
        if (VrmsB > CH_FLOATING_EXIT){ useAllForB = false; useAllB_since = 0; }
      }
    }else{ useAllForB=false; useAllB_since=0; }

    bool onlyAon = (Aon && !Bon);
    bool onlyBon = (Bon && !Aon);
    bool allowUseAllA = useAllForA && onlyAon && (nowMs - useAllA_since >= SUB_IN_DELAY_MS);
    bool allowUseAllB = useAllForB && onlyBon && (nowMs - useAllB_since >= SUB_IN_DELAY_MS);

    float vA_show = Aon ? (allowUseAllA ? VrmsALL : VrmsA) : 0.0f;
    float vB_show = Bon ? (allowUseAllB ? VrmsALL : VrmsB) : 0.0f;

    voltageA   = round1(vA_show);
    voltageB   = round1(vB_show);
    voltageAll = round1(VrmsALL);

    // กำลังแบบ Apparent
    float pA = vA_show * IrmsA;
    float pB = vB_show * IrmsB;
    if (!Aon) pA = 0.0f;
    if (!Bon) pB = 0.0f;

    powerA = round2( ema_pA.filt(pA) );
    powerB = round2( ema_pB.filt(pB) );

    float powerTotal = 0.0f;
    if (Aon) powerTotal += powerA;
    if (Bon) powerTotal += powerB;
    if (powerTotal < 0) powerTotal = 0;

    energyWh += powerTotal * (1.0f/3600.0f);

    // Debug กระแส B (ช่วยไล่คาลิเบรต)
    Serial.printf("[DBG] IrmsB_raw=%.6f  IrmsB=%.4fA  vB=%.1fV\n",
                  iB_r.rms(), iB_r.rms()*iB_scaleA_perV, vB_show);

    vA_r.reset(); vB_r.reset(); vALL_r.reset();
    iA_r.reset(); iB_r.reset(); iALL_r.reset();
    sumW_A=0; sumW_B=0; nW_A=0; nW_B=0; last1s=nowMs;

    if (!Aon && currentA != 0.0f) currentA = 0.0f;
    if (!Bon && currentB != 0.0f) currentB = 0.0f;

    updateStatusNow();
  }

  /* ===== Overcurrent ===== */
  bool overA = (currentA > LIMIT_A + LIMIT_MARGIN) || (instIA > LIMIT_A + LIMIT_MARGIN);
  bool overB = (currentB > LIMIT_B + LIMIT_MARGIN) || (instIB > LIMIT_B + LIMIT_MARGIN);

  bool trippedA = false, trippedB = false;

  if (relayA && !latchedA){
    if (overA){
      if (aOverStart==0) aOverStart=nowMs;
      if (nowMs - aOverStart >= TRIP_HOLD_MS){
        relayA=false; onRelayAChange(); latchedA=true; aOverStart=0;
        trippedA=true;
      }
    }else aOverStart=0;
  }
  if (relayB && !latchedB){
    if (overB){
      if (bOverStart==0) bOverStart=nowMs;
      if (nowMs - bOverStart >= TRIP_HOLD_MS){
        relayB=false; onRelayBChange(); latchedB=true; bOverStart=0;
        trippedB=true;
      }
    }else bOverStart=0;
  }

  if (trippedA || trippedB){
    if (trippedA && trippedB){
      float limMax = (LIMIT_A > LIMIT_B) ? LIMIT_A : LIMIT_B;
      setAlertMessage("plugA and plugB กระแสเกิน(" + fmt2(limMax) + "A) ตัดโหลดแล้ว");
      tripA_flag = true; tripB_flag = true; needImmediatePost = true;
    }else if (trippedA){
      setAlertMessage("plugA กระแสเกิน(" + fmt2(LIMIT_A) + "A) ตัดโหลดแล้ว");
      tripA_flag = true; needImmediatePost = true;
    }else{
      setAlertMessage("plugB กระแสเกิน(" + fmt2(LIMIT_B) + "A) ตัดโหลดแล้ว");
      tripB_flag = true; needImmediatePost = true;
    }
  }else{
    setAlertMessage("Plug A: ทำงานปกติ Plug B: ทำงานปกติ");
  }

  /* ===== Timers ===== */
  if (due(A_onAt_s,now_utc)) { A_onAt_s=0; saveTimers(); relayA=true;  onRelayAChange();  showNextA=false; Serial.println("[Timer] A -> ON"); }
  if (due(A_offAt_s,now_utc)){ A_offAt_s=0; saveTimers(); relayA=false; onRelayAChange();  showNextA=false; Serial.println("[Timer] A -> OFF"); }
  if (due(B_onAt_s,now_utc)) { B_onAt_s=0; saveTimers(); relayB=true;  onRelayBChange();  showNextB=false; Serial.println("[Timer] B -> ON"); }
  if (due(B_offAt_s,now_utc)){ B_offAt_s=0; saveTimers(); relayB=false; onRelayBChange();  showNextB=false; Serial.println("[Timer] B -> OFF"); }

  if (A_onAt_s==0 && A_offAt_s==0 && B_onAt_s==0 && B_offAt_s==0){
    showNextAll = false; showOnlyAll = false;
  }

  // Refresh NTP/RTC ทุก 30s
  static unsigned long lastNtpCheck=0;
  if (millis() - lastNtpCheck > 30000UL) {
    time_t t = time(nullptr);
    if (t > 1700000000) {
      if (!ntpOK) Serial.println("[NTP] acquired.");
      ntpOK = true;
      if (rtcOK) {
        uint32_t rtcNow = rtc.now().unixtime();
        if (labs((long)rtcNow - (long)t) > 2) {
          rtc.adjust(DateTime((uint32_t)t));
          Serial.println("[RTC] re-sync from NTP.");
        }
      }
    }
    lastNtpCheck = millis();
  }

  /* ==== ส่งขึ้นชีตตามรอบเวลา หรือเมื่อมีเหตุ ==== */
  if (needImmediatePost || (millis() - lastPostMs >= POST_INTERVAL_MS)) {
    needImmediatePost = false;
    lastPostMs = millis();
    postToGoogleSheet();
  }
}

/* ==== Cloud callbacks ==== */
void onMsgCommandChange(){
  if (g_echoing) { Serial.println("[CB] echo skip"); return; }
  String raw = msgCommand;
  Serial.println(String("[CB] onMsgCommandChange raw='")+raw+"' len="+raw.length());

  String all = normalizeSpaces(raw); if (all.length()==0){ showSuggestions('?'); return; }
  String u = toUpperAscii(all); if (u=="HELP" || u=="?"){ showSuggestions('?'); return; }

  int start=0; bool anyOK=false;
  while (start < (int)all.length()){
    int comma = all.indexOf(',', start);
    String part = (comma>=0)? all.substring(start, comma) : all.substring(start);
    part.trim(); start = (comma>=0)? comma+1 : all.length(); if (part.length()==0) continue;

    String who, act, tail; split3Tokens(part, who, act, tail);

    if (act.length()==0 || act=="?" || act=="？"){
      if (isAny(who,"A",nullptr,nullptr)) showSuggestions('A');
      else if (isAny(who,"B",nullptr,nullptr)) showSuggestions('B');
      else if (isAny(who,"ALL","ทั้งหมด",nullptr)) showSuggestions('X');
      else showSuggestions('?'); anyOK=true; continue;
    }

    char which=0;
    if (isAny(who,"A",nullptr,nullptr)) which='A';
    else if (isAny(who,"B",nullptr,nullptr)) which='B';
    else if (isAny(who,"ALL","ทั้งหมด",nullptr)) which='X';
    else { Serial.println("[Msg] Skip (WHO?): "+part); continue; }

    bool isCancel=false, turnOn=false;
    if (isAny(act,"ON","OPEN","เปิด")) turnOn=true;
    else if (isAny(act,"OFF","CLOSE","ปิด")) turnOn=false;
    else if (isAny(act,"CANCEL","ยกเลิก",nullptr)) isCancel=true;
    else { Serial.println("[Msg] Skip (ACTION?): "+part); continue; }

    if (isCancel){ cancelTimers(which?which:'X'); anyOK=true; continue; }

    bool handledAbs=false;
    if (tail.length()>0){
      int _h,_m;
      if (hasAtKeyword(tail) || findHHMM(tail, _h, _m)){
        uint32_t whenUTC = parseLocalHHMM_toUTC(tail);
        if (whenUTC != 0){ scheduleActionAt(which?which:'X', turnOn, whenUTC); anyOK=true; handledAbs=true; }
      }
    }
    if (handledAbs) continue;

    int mins = parseDurationToMinutes(tail);
    scheduleAction(which?which:'X', turnOn, mins); anyOK=true;
  }
  if (!anyOK) showSuggestions('?');
}

void onRelayAChange(){ if (relayA) latchedA=false; digitalWrite(RELAY_A_PIN, relayA?RELAY_ON:RELAY_OFF); }
void onRelayBChange(){ if (relayB) latchedB=false; digitalWrite(RELAY_B_PIN, relayB?RELAY_ON:RELAY_OFF); }
void onResetEnergyChange(){ if (resetEnergy){ energyWh=0.0f; resetEnergy=false; Serial.println("[Cloud] Energy reset."); } }

/* ==== ส่งขึ้นชีต (GET) ==== */
void postToGoogleSheet(){
  WiFiClientSecure client; client.setInsecure();
  HTTPClient https;
  https.setTimeout(8000);
  https.setFollowRedirects(HTTPC_FORCE_FOLLOW_REDIRECTS);

  String url = String(SCRIPT_URL) + "?k=" + SHEET_SECRET
    + "&swA=" + (relayA ? "true":"false")
    + "&swB=" + (relayB ? "true":"false")
    + "&iIn=" + String(currentAll,3)
    + "&vIn=" + String(voltageAll,1)
    + "&vA="  + String(voltageA,1)
    + "&vB="  + String(voltageB,1)
    + "&iA="  + String(currentA,3)
    + "&iB="  + String(currentB,3)
    + "&pA="  + String(powerA,2)
    + "&pB="  + String(powerB,2)
    + "&tC="  + String(tempC,1)
    + "&hum=" + String(humidity,1)
    + "&tripA=" + (tripA_flag ? "true":"false")
    + "&tripB=" + (tripB_flag ? "true":"false");

  if (!https.begin(client, url)) { Serial.println("[Sheet] begin() failed"); return; }
  int code = https.GET();
  String resp = https.getString();
  https.end();
  Serial.printf("[Sheet] GET %d: %s\n", code, resp.c_str());

  tripA_flag = false; tripB_flag = false;
}

code

#include "thingProperties.h"
#include <Arduino.h>
#include <math.h>
#include <DHT.h>
#include <Wire.h>
#include <RTClib.h>
#include <Preferences.h>
#include <time.h>

/* ==== ส่ง Google Sheet (ใช้ GET) ==== */
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
const char* SCRIPT_URL   = "https://script.google.com/macros/s/AKfycbx9z_d7pARnuMMtig9l54V5C6MldyGrKKmQ76MqW-7N-9NMQYWbUsr2iKnz5yeJaontLA/exec";
const char* SHEET_SECRET = "Smart_Plug";
const unsigned long POST_INTERVAL_MS = 60000UL;
unsigned long lastPostMs = 0;
volatile bool needImmediatePost = false;
static bool tripA_flag = false;
static bool tripB_flag = false;

/* ===== Pin map ===== */
#ifndef D2
#define D2 2
#endif
#ifndef D5
#define D5 5
#endif
#define RELAY_A_PIN D2
#define RELAY_B_PIN D5
#define RELAY_ON  HIGH
#define RELAY_OFF LOW

#define ADC_V_A    A0   // ZMPT A
#define ADC_V_B    A1   // ZMPT B
#define ADC_I_A    A3   // ACS712 A
#define ADC_I_B    A2   // ACS712 B
#define I2C_SDA    A4   // DS3231 SDA
#define I2C_SCL    A5   // DS3231 SCL
#define ADC_I_ALL  A6   // SCT013 All
#define ADC_V_ALL  A7   // ZMPT All

// DHT11
#define DHTPIN   D8
#define DHTTYPE  DHT11
DHT dht(DHTPIN, DHTTYPE);

/* ===== ADC helpers ===== */
const float ADC_REF = 3.3f;
const int   ADC_MAX = 4095;
inline float adcToVolt(int raw){ return (ADC_REF * raw) / ADC_MAX; }
inline int readADConce(int pin){ analogRead(pin); return analogRead(pin); }
float measureOffsetV(uint8_t pin,int n=400){ double s=0; for(int i=0;i<n;i++) s+=adcToVolt(readADConce(pin)); return s/n; }
auto round1=[](float x){ return roundf(x*10.0f)/10.0f; };
auto round2=[](float x){ return roundf(x*100.0f)/100.0f; };
auto zfloor=[](float x,float th){ return (fabsf(x)<th)?0.0f:x; };

/* ===== คาลิเบรต (ปรับได้) =====
   NOTE: ตั้ง scale ให้ตรงรุ่น ACS712
   - 05B → 5.405 A/V
   - 20A → 10.0 A/V
   - 30A → 15.15 A/V
*/
float iA_offsetV=2.50f, iB_offsetV=2.50f, iALL_offsetV=2.50f;
float vA_offsetV=2.50f, vB_offsetV=2.50f, vALL_offsetV=2.50f;

float iA_scaleA_perV=10.0f;     // ← ถ้า 05B ให้เปลี่ยนเป็น 5.405f
float iB_scaleA_perV=10.0f;     // ← ถ้า 05B ให้เปลี่ยนเป็น 5.405f
float iALL_scaleA_perV=10.0f;   // CT (SCT013) ปรับด้วยการคาลิเบรต
float vA_scaleV_perV=221.90f, vB_scaleV_perV=220.94f, vALL_scaleV_perV=223.36f;

/* ===== Overcurrent ===== */
const float LIMIT_A = 10.0f, LIMIT_B = 10.0f, LIMIT_MARGIN = 0.5f;
const unsigned long TRIP_HOLD_MS = 200;
bool latchedA=false, latchedB=false;
unsigned long aOverStart=0, bOverStart=0;

/* ===== RMS ===== */
struct RMS{ double sum=0,sum2=0; uint32_t n=0;
  inline void push(float x){ sum+=x; sum2+= (double)x*x; n++; }
  inline float rms() const { if(!n) return 0; double m=sum/n; double v=sum2/n - m*m; if(v<0) v=0; return sqrt(v); }
  inline void reset(){ sum=0; sum2=0; n=0; }
};
RMS iA_r,iB_r,iALL_r, vA_r,vB_r,vALL_r;

/* ===== EMA ===== */
struct EMA{ float y=0; bool init=false; float alpha=0.2f;
  void setTauSeconds(float tau){ if(tau<=0) alpha=1; else alpha = 1.0f - expf(-1.0f/tau); }
  float filt(float x){ if(!init){ y=x; init=true; } else y = alpha*x + (1-alpha)*y; return y; }
  void reset(){ init=false; }
};
EMA ema_iA,ema_iB,ema_iALL, ema_pA,ema_pB, ema_temp,ema_hum;
void setupSmoothers(){ float TAU=3.0f;
  ema_iA.setTauSeconds(TAU); ema_iB.setTauSeconds(TAU); ema_iALL.setTauSeconds(TAU);
  ema_pA.setTauSeconds(TAU); ema_pB.setTauSeconds(TAU);
  ema_temp.setTauSeconds(5.0f); ema_hum.setTauSeconds(5.0f);
}

/* ===== ระบบ/พลังงาน ===== */
double   sumW_A=0, sumW_B=0;
uint32_t nW_A=0,  nW_B=0;
unsigned long last1s=0;

Preferences prefs;

/* ===== Cloud reply helper ===== */
volatile bool g_echoing=false;
inline void pushReply(const String& s){ msgReply=s; Serial.println("[Reply] "+s);
  g_echoing=true; msgCommand=s; ArduinoCloud.update(); g_echoing=false; }

void setAlertMessage(const String& s){
  static String last;
  if (s != last){
    msgReply = s;
    ocAlert  = s;
    Serial.println("[Alert] " + s);
    last = s;
    needImmediatePost = true;
  }
}
String fmt2(float x){ char b[16]; snprintf(b, sizeof(b), "%.2f", x); return String(b); }

/* ===== RTC / Time ===== */
RTC_DS3231 rtc; bool rtcOK=false, ntpOK=false;
const long TZ_OFFSET_SEC = 7L*3600L;
static inline uint32_t compileUTC(){ DateTime c(F(__DATE__),F(__TIME__)); return c.unixtime(); }
inline uint32_t nowUtc(){ time_t t=time(nullptr); if(ntpOK && t>1700000000) return (uint32_t)t;
  if(rtcOK) return rtc.now().unixtime(); static uint32_t boot=0; if(!boot) boot=compileUTC(); return boot + millis()/1000UL; }

/* ===== time utils (TH) ===== */
String humanDeltaTH_fromSeconds(uint32_t d){ if((int32_t)d<=0) return "เดี๋ยวนี้";
  unsigned long s=d,h=s/3600; s%=3600; unsigned long m=s/60; s%=60; if(s>0)m++;
  if(m>=60){ h+=m/60; m%=60; } String out="อีก "; if(h){ out+=String(h)+" ชั่วโมง"; if(m) out+=" "+String(m)+" นาที"; }
  else if(m) out+=String(m)+" นาที"; else out+="น้อยกว่า 1 นาที"; return out; }
String formatWhenRelativeUTC(uint32_t t){ uint32_t n=nowUtc(); return humanDeltaTH_fromSeconds(t>n?t-n:0); }

/* ===== Timers (UTC) + โหมดโชว์เฉพาะ All ===== */
uint32_t A_onAt_s=0,A_offAt_s=0,B_onAt_s=0,B_offAt_s=0;
bool showNextA=false, showNextB=false, showNextAll=false;
bool showOnlyAll=false;
void saveTimers(){ prefs.begin("timers",false);
  prefs.putUInt("A_on",A_onAt_s); prefs.putUInt("A_off",A_offAt_s);
  prefs.putUInt("B_on",B_onAt_s); prefs.putUInt("B_off",B_offAt_s); prefs.end(); }
void loadTimers(){ prefs.begin("timers",true);
  A_onAt_s=prefs.getUInt("A_on",0); A_offAt_s=prefs.getUInt("A_off",0);
  B_onAt_s=prefs.getUInt("B_on",0); B_offAt_s=prefs.getUInt("B_off",0); prefs.end(); }
inline bool due(uint32_t when_s,uint32_t now_s){ return (when_s!=0)&&((int32_t)(now_s-when_s)>=0); }
int clampMinutes(int m){ if(m<0)return 0; if(m>1440)return 1440; return m; }

/* ===== Parser / Command ===== */
String normalizeSpaces(String s){
  s.trim();
  const char* specials[] = { "\xC2\xA0", "\xE2\x80\x8B", "\xE2\x80\x8C", "\xE2\x80\x8D" };
  for (const char* pat : specials) while (s.indexOf(pat) >= 0) s.replace(pat, " ");
  while (s.indexOf("  ") >= 0) s.replace("  ", " ");
  return s;
}
String toUpperAscii(String s){ for(size_t i=0;i<s.length();++i){ char c=s[i]; if(c>='a'&&c<='z') s[i]=c-32; } return s; }
void split3Tokens(const String& s,String& t1,String& t2,String& t3){ int p1=s.indexOf(' '); if(p1<0){t1=s; t2=t3="";return;}
  t1=s.substring(0,p1); int p2=s.indexOf(' ',p1+1); if(p2<0){t2=s.substring(p1+1); t3=""; return;}
  t2=s.substring(p1+1,p2); t3=s.substring(p2+1); t1.trim(); t2.trim(); t3.trim();}

bool isAny(const String& token,const char* a,const char* b,const char* c){
  String T=toUpperAscii(token);
  if(a){String A=a; if(toUpperAscii(A)==T||token==A) return true;}
  if(b){String B=b; if(toUpperAscii(B)==T||token==B) return true;}
  if(c){String C=c; if(toUpperAscii(C)==T||token==C) return true;}
  return false;
}

String join(const char* a[],int n){ String s; for(int i=0;i<n;i++){ if(i) s+=" | "; s+=a[i]; } return s; }
void showSuggestions(char which){
  if(which=='?'){ const char* root[]={"A ...","B ...","All ...","help"};
    pushReply("Try: "+join(root,4)+"\nตัวอย่าง: A เปิด 2 ชั่วโมง 30 นาที, B ปิด 30 นาที, All on at 21:30"); return; }
  const char* th[]={"เปิด [เวลา]","ปิด [เวลา]","ยกเลิก"}; const char* en[]={"on [time]","off [time]","cancel"};
  String head=(which=='A')?"A":(which=='B')?"B":"All";
  pushReply(head+" → "+join(th,3)+"\nEN: "+head+" "+join(en,3)+"\n[เวลา]= 30 นาที | 1 ชั่วโมง | 2 ชั่วโมง 30 นาที | at 21:30");
}
int extractFirstInt(const String& s){ String d=""; for(size_t i=0;i<s.length();++i){ char c=s[i]; if(c>='0'&&c<='9') d+=c; else if(d.length()) break; } return d.length()? d.toInt():-1; }
bool hasHourUnit(String s){ String u=toUpperAscii(s);
  if(u.indexOf("HR")>=0||u.indexOf("H ")>=0||u.endsWith("H")) return true;
  if(s.indexOf("ชั่วโมง")>=0||s.indexOf("ชม.")>=0) return true; return false; }
bool hasMinuteUnit(String s){ String u=toUpperAscii(s); if(u.indexOf("MIN")>=0 || u=="M" || u.endsWith(" M")) return true; if(s.indexOf("นาที")>=0) return true; return false; }
int parseDurationToMinutes(String s){
  s=normalizeSpaces(s); s.replace("อีก",""); s.trim(); int total=0,pos=0;
  while(pos<(int)s.length()){ while(pos<(int)s.length()&&s[pos]==' ') pos++; if(pos>=(int)s.length()) break;
    int ns=s.indexOf(' ',pos); String token=(ns<0)? s.substring(pos): s.substring(pos,ns); pos=(ns<0)? s.length():ns+1;
    int v=extractFirstInt(token); if(v<0) continue; bool handled=false;
    if(hasHourUnit(token)){ total+=v*60; handled=true; }
    else if(hasMinuteUnit(token)){ total+=v; handled=true; }
    else{ int ns2=s.indexOf(' ',pos); String next=(ns2<0)? s.substring(pos): s.substring(pos,ns2);
      if(next.length()){ if(hasHourUnit(next)){ total+=v*60; handled=true; pos=(ns2<0? s.length(): ns2+1); }
        else if(hasMinuteUnit(next)){ total+=v; handled=true; pos=(ns2<0? s.length(): ns2+1);} } }
    if(!handled) total+=v; }
  return clampMinutes(total);
}
bool hasAtKeyword(String s){
  s=normalizeSpaces(s); String u=toUpperAscii(s);
  if(u.indexOf(" AT ")>=0 || u.startsWith("AT ") || u.endsWith(" AT")) return true;
  if (s.indexOf("เวลา")>=0) return true; return false;
}
bool findHHMM(const String& s,int& hh,int& mm){
  int c=s.indexOf(':'); if(c<0) return false; int l=c-1; while(l>=0 && isDigit(s[l])) l--; l++;
  int r=c+1; while(r<(int)s.length() && isDigit(s[r])) r++; String H=s.substring(l,c), M=s.substring(c+1,r);
  if(H.length()==0||M.length()<1) return false; int h=H.toInt(), m=M.toInt(); if(h<0||h>23||m<0||m>59) return false; hh=h; mm=m; return true;
}
uint32_t parseLocalHHMM_toUTC(const String& tail){
  int hh=-1,mm=-1; if(!findHHMM(tail,hh,mm)) return 0; uint32_t now=nowUtc();
  DateTime nowL(now+TZ_OFFSET_SEC); DateTime tgtL(nowL.year(),nowL.month(),nowL.day(),hh,mm,0);
  uint32_t tgt=tgtL.unixtime()-TZ_OFFSET_SEC; if((int32_t)(tgt-now)<=0) tgt=(tgtL+TimeSpan(1,0,0,0)).unixtime()-TZ_OFFSET_SEC; return tgt;
}

/* ===== Actions / status ===== */
String whoStr(char w){ return String((w=='X')?"ALL":(w=='A'?"A":"B")); }
String actFutureTH(bool on){ return String(on? "จะเปิด":"จะปิด"); }
void scheduleAction(char which,bool turnOn,int minutes){
  minutes=clampMinutes(minutes); uint32_t when=nowUtc() + (uint32_t)minutes*60UL;
  if(which=='A'||which=='X'){ if(turnOn) A_onAt_s=(minutes==0)? nowUtc():when; else A_offAt_s=(minutes==0)? nowUtc():when; }
  if(which=='B'||which=='X'){ if(turnOn) B_onAt_s=(minutes==0)? nowUtc():when; else B_offAt_s=(minutes==0)? nowUtc():when; }
  if(which=='A') showNextA=(minutes>0);
  else if(which=='B') showNextB=(minutes>0);
  else if(which=='X'){ showNextAll=(minutes>0); showNextA=showNextB=false; showOnlyAll=true; }
  saveTimers();
  pushReply(whoStr(which)+" "+actFutureTH(turnOn)+" "+(minutes? formatWhenRelativeUTC(when):"เดี๋ยวนี้"));
}
void scheduleActionAt(char which,bool turnOn,uint32_t when){
  if(which=='A'||which=='X'){ if(turnOn) A_onAt_s=when; else A_offAt_s=when; }
  if(which=='B'||which=='X'){ if(turnOn) B_onAt_s=when; else B_offAt_s=when; }
  if(which=='A') showNextA=(when>nowUtc());
  else if(which=='B') showNextB=(when>nowUtc());
  else if(which=='X'){ showNextAll=(when>nowUtc()); showNextA=showNextB=false; showOnlyAll=true; }
  saveTimers(); pushReply(whoStr(which)+" "+actFutureTH(turnOn)+" "+formatWhenRelativeUTC(when));
}
void cancelTimers(char which){
  if(which=='A'||which=='X'){ A_onAt_s=0; A_offAt_s=0; showNextA=false; }
  if(which=='B'||which=='X'){ B_onAt_s=0; B_offAt_s=0; showNextB=false; }
  if(which=='X'){ showNextAll=false; showOnlyAll=false; }
  saveTimers(); pushReply(whoStr(which)+" ยกเลิกตัวจับเวลาแล้ว");
}
String relStr(uint32_t when){ if(!when) return ""; return formatWhenRelativeUTC(when); }
String nextABText(char w){ uint32_t onT=(w=='A')?A_onAt_s:B_onAt_s, offT=(w=='A')?A_offAt_s:B_offAt_s;
  if(!onT && !offT) return ""; if(onT && (!offT || (int32_t)(onT-offT)<0)) return String("(จะเปิด ")+relStr(onT)+")";
  return String("(จะปิด ")+relStr(offT)+")"; }
String nextALLText(){ uint32_t tmin=0; bool isOn=false; uint32_t ts[4]={A_onAt_s,A_offAt_s,B_onAt_s,B_offAt_s}; bool ton[4]={true,false,true,false};
  for(int i=0;i<4;i++){ if(!ts[i]) continue; if(!tmin || (int32_t)(ts[i]-tmin)<0){ tmin=ts[i]; isOn=ton[i]; } }
  if(!tmin) return ""; return String(isOn? "จะเปิด ":"จะปิด ")+relStr(tmin);
}
void updateStatusNow(){
  if(showOnlyAll){
    String t=nextALLText();
    String line = t.length()? ("All: "+t) : (String("All: ")+((relayA||relayB)?"เปิดใช้งาน":"ปิดใช้งาน"));
    if(statusNow!=line){ statusNow=line; Serial.println(String("[Status] ")+statusNow); }
    return;
  }
  String aState=relayA?"เปิดใช้งาน":"ปิดใช้งาน";
  String bState=relayB?"เปิดใช้งาน":"ปิดใช้งาน";
  String msg="Plug A: "+aState; if(showNextA){ String t=nextABText('A'); if(t.length()) msg+=" "+t; }
  msg+="\nPlug B: "+bState; if(showNextB){ String t=nextABText('B'); if(t.length()) msg+=" "+t; }
  if(showNextAll){ String t=nextALLText(); if(t.length()) msg+="\nAll: "+t; }
  static String last=""; if(msg!=last){ statusNow=msg; last=msg; Serial.println(String("[Status] ")+msg); }
}

/* ==== setup ==== */
void setup(){
  Serial.begin(115200); delay(1500);
  Serial.println("[BOOT] Smart Plug");

  initProperties();
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // NTP UTC
  configTzTime("UTC0","pool.ntp.org","time.google.com","time.nist.gov");
  for (int i=0;i<30;i++){ time_t t=time(nullptr); if (t>1700000000){ ntpOK=true; break; } delay(100); }

  pinMode(RELAY_A_PIN, OUTPUT); pinMode(RELAY_B_PIN, OUTPUT);
  digitalWrite(RELAY_A_PIN, relayA ? RELAY_ON : RELAY_OFF);
  digitalWrite(RELAY_B_PIN, relayB ? RELAY_ON : RELAY_OFF);

  /* ★★ ADC config ★★ */
  analogReadResolution(12);
  analogSetPinAttenuation(ADC_V_A,  ADC_11db);
  analogSetPinAttenuation(ADC_V_B,  ADC_11db);
  analogSetPinAttenuation(ADC_V_ALL,ADC_11db);
  analogSetPinAttenuation(ADC_I_A,  ADC_11db);
  analogSetPinAttenuation(ADC_I_B,  ADC_11db);
  analogSetPinAttenuation(ADC_I_ALL,ADC_11db);

  dht.begin();

  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(100000);

  if (rtc.begin()){
    rtcOK = true;
    if (ntpOK){ rtc.adjust(DateTime((uint32_t)time(nullptr))); Serial.println("[RTC] Sync from NTP."); }
    else if (rtc.lostPower()){ rtc.adjust(DateTime(compileUTC())); Serial.println("[RTC] Lost power - set UTC from compile time."); }
  }else{
    rtcOK = false; Serial.println("[RTC] DS3231 not found; using uptime/NTP.");
  }

  // วัด offset ตอนบูต (ถอดโหลดจะดีที่สุด)
  iA_offsetV = measureOffsetV(ADC_I_A);
  iB_offsetV = measureOffsetV(ADC_I_B);
  iALL_offsetV = measureOffsetV(ADC_I_ALL);
  vA_offsetV = measureOffsetV(ADC_V_A);
  vB_offsetV = measureOffsetV(ADC_V_B);
  vALL_offsetV = measureOffsetV(ADC_V_ALL);

  Serial.printf("[ADC off] iA=%.3fV iB=%.3fV iALL=%.3fV | vA=%.3fV vB=%.3fV vALL=%.3fV\n",
    iA_offsetV,iB_offsetV,iALL_offsetV,vA_offsetV,vB_offsetV,vALL_offsetV);

  loadTimers();
  setupSmoothers();
  statusNow = "พร้อมใช้งาน";
}

/* ===== กันปลายลอย + หน่วงแสดงผล ===== */
const float MAINS_VALID_MIN     = 180.0f;
const float CH_FLOATING_MAX_ON  =  60.0f;
const float CH_FLOATING_EXIT    =  80.0f;
const unsigned long SUB_IN_DELAY_MS = 1000;

bool useAllForA=false, useAllForB=false;
unsigned long useAllA_since=0, useAllB_since=0;

void loop(){
  ArduinoCloud.update();
  unsigned long nowMs = millis();
  uint32_t now_utc = nowUtc();

  // DHT ~2s
  static unsigned long lastDHT=0;
  if(nowMs - lastDHT >= 2000){
    float h=dht.readHumidity(), t=dht.readTemperature();
    if(!isnan(h)&&!isnan(t)){ humidity=round1(ema_hum.filt(h)); tempC=round1(ema_temp.filt(t)); }
    lastDHT=nowMs;
  }

  /* ===== อ่าน ADC สะสม RMS ===== */
  float vVA   = adcToVolt(readADConce(ADC_V_A))   - vA_offsetV;
  float vVB   = adcToVolt(readADConce(ADC_V_B))   - vB_offsetV;
  float vVALL = adcToVolt(readADConce(ADC_V_ALL)) - vALL_offsetV;

  float vIA   = adcToVolt(readADConce(ADC_I_A))   - iA_offsetV;
  float vIB   = adcToVolt(readADConce(ADC_I_B))   - iB_offsetV;
  float vIALL = adcToVolt(readADConce(ADC_I_ALL)) - iALL_offsetV;

  vA_r.push(vVA); vB_r.push(vVB); vALL_r.push(vVALL);
  iA_r.push(vIA); iB_r.push(vIB); iALL_r.push(vIALL);

  // instant สำหรับ OC (จับยอดไว)
  float instIA = fabsf(vIA)*iA_scaleA_perV;
  float instIB = fabsf(vIB)*iB_scaleA_perV;

  if(nowMs - last1s >= 1000){
    rtcISO = String("ok:") + (ntpOK? "ntp" : (rtcOK? "rtc-utc":"uptime-utc"));

    float VrmsA=vA_r.rms()*vA_scaleV_perV;
    float VrmsB=vB_r.rms()*vB_scaleV_perV;
    float VrmsALL=vALL_r.rms()*vALL_scaleV_perV;
    float IrmsA=iA_r.rms()*iA_scaleA_perV;
    float IrmsB=iB_r.rms()*iB_scaleA_perV;
    float IrmsALL=iALL_r.rms()*iALL_scaleA_perV;

    // ★ เดดโซนเล็กลง 0.003A เพื่อเห็นโหลดเล็ก ๆ
    currentA   = zfloor(round2( ema_iA.filt(IrmsA) ), 0.003f);
    currentB   = zfloor(round2( ema_iB.filt(IrmsB) ), 0.003f);
    currentAll = zfloor(round2( ema_iALL.filt(IrmsALL) ), 0.003f);

    /* ===== anti-floating: เลือกแรงดันโชว์ ===== */
    bool Aon = relayA;
    bool Bon = relayB;

    if (Aon){
      if (!useAllForA){
        if (VrmsA < CH_FLOATING_MAX_ON && VrmsALL > MAINS_VALID_MIN){ useAllForA = true; useAllA_since = nowMs; }
      }else{
        if (VrmsA > CH_FLOATING_EXIT){ useAllForA = false; useAllA_since = 0; }
      }
    }else{ useAllForA=false; useAllA_since=0; }

    if (Bon){
      if (!useAllForB){
        if (VrmsB < CH_FLOATING_MAX_ON && VrmsALL > MAINS_VALID_MIN){ useAllForB = true; useAllB_since = nowMs; }
      }else{
        if (VrmsB > CH_FLOATING_EXIT){ useAllForB = false; useAllB_since = 0; }
      }
    }else{ useAllForB=false; useAllB_since=0; }

    bool onlyAon = (Aon && !Bon);
    bool onlyBon = (Bon && !Aon);
    bool allowUseAllA = useAllForA && onlyAon && (nowMs - useAllA_since >= SUB_IN_DELAY_MS);
    bool allowUseAllB = useAllForB && onlyBon && (nowMs - useAllB_since >= SUB_IN_DELAY_MS);

    float vA_show = Aon ? (allowUseAllA ? VrmsALL : VrmsA) : 0.0f;
    float vB_show = Bon ? (allowUseAllB ? VrmsALL : VrmsB) : 0.0f;

    voltageA   = round1(vA_show);
    voltageB   = round1(vB_show);
    voltageAll = round1(VrmsALL);

    // กำลังแบบ Apparent
    float pA = vA_show * IrmsA;
    float pB = vB_show * IrmsB;
    if (!Aon) pA = 0.0f;
    if (!Bon) pB = 0.0f;

    powerA = round2( ema_pA.filt(pA) );
    powerB = round2( ema_pB.filt(pB) );

    float powerTotal = 0.0f;
    if (Aon) powerTotal += powerA;
    if (Bon) powerTotal += powerB;
    if (powerTotal < 0) powerTotal = 0;

    energyWh += powerTotal * (1.0f/3600.0f);

    // Debug กระแส B (ช่วยไล่คาลิเบรต)
    Serial.printf("[DBG] IrmsB_raw=%.6f  IrmsB=%.4fA  vB=%.1fV\n",
                  iB_r.rms(), iB_r.rms()*iB_scaleA_perV, vB_show);

    vA_r.reset(); vB_r.reset(); vALL_r.reset();
    iA_r.reset(); iB_r.reset(); iALL_r.reset();
    sumW_A=0; sumW_B=0; nW_A=0; nW_B=0; last1s=nowMs;

    if (!Aon && currentA != 0.0f) currentA = 0.0f;
    if (!Bon && currentB != 0.0f) currentB = 0.0f;

    updateStatusNow();
  }

  /* ===== Overcurrent ===== */
  bool overA = (currentA > LIMIT_A + LIMIT_MARGIN) || (instIA > LIMIT_A + LIMIT_MARGIN);
  bool overB = (currentB > LIMIT_B + LIMIT_MARGIN) || (instIB > LIMIT_B + LIMIT_MARGIN);

  bool trippedA = false, trippedB = false;

  if (relayA && !latchedA){
    if (overA){
      if (aOverStart==0) aOverStart=nowMs;
      if (nowMs - aOverStart >= TRIP_HOLD_MS){
        relayA=false; onRelayAChange(); latchedA=true; aOverStart=0;
        trippedA=true;
      }
    }else aOverStart=0;
  }
  if (relayB && !latchedB){
    if (overB){
      if (bOverStart==0) bOverStart=nowMs;
      if (nowMs - bOverStart >= TRIP_HOLD_MS){
        relayB=false; onRelayBChange(); latchedB=true; bOverStart=0;
        trippedB=true;
      }
    }else bOverStart=0;
  }

  if (trippedA || trippedB){
    if (trippedA && trippedB){
      float limMax = (LIMIT_A > LIMIT_B) ? LIMIT_A : LIMIT_B;
      setAlertMessage("plugA and plugB กระแสเกิน(" + fmt2(limMax) + "A) ตัดโหลดแล้ว");
      tripA_flag = true; tripB_flag = true; needImmediatePost = true;
    }else if (trippedA){
      setAlertMessage("plugA กระแสเกิน(" + fmt2(LIMIT_A) + "A) ตัดโหลดแล้ว");
      tripA_flag = true; needImmediatePost = true;
    }else{
      setAlertMessage("plugB กระแสเกิน(" + fmt2(LIMIT_B) + "A) ตัดโหลดแล้ว");
      tripB_flag = true; needImmediatePost = true;
    }
  }else{
    setAlertMessage("Plug A: ทำงานปกติ Plug B: ทำงานปกติ");
  }

  /* ===== Timers ===== */
  if (due(A_onAt_s,now_utc)) { A_onAt_s=0; saveTimers(); relayA=true;  onRelayAChange();  showNextA=false; Serial.println("[Timer] A -> ON"); }
  if (due(A_offAt_s,now_utc)){ A_offAt_s=0; saveTimers(); relayA=false; onRelayAChange();  showNextA=false; Serial.println("[Timer] A -> OFF"); }
  if (due(B_onAt_s,now_utc)) { B_onAt_s=0; saveTimers(); relayB=true;  onRelayBChange();  showNextB=false; Serial.println("[Timer] B -> ON"); }
  if (due(B_offAt_s,now_utc)){ B_offAt_s=0; saveTimers(); relayB=false; onRelayBChange();  showNextB=false; Serial.println("[Timer] B -> OFF"); }

  if (A_onAt_s==0 && A_offAt_s==0 && B_onAt_s==0 && B_offAt_s==0){
    showNextAll = false; showOnlyAll = false;
  }

  // Refresh NTP/RTC ทุก 30s
  static unsigned long lastNtpCheck=0;
  if (millis() - lastNtpCheck > 30000UL) {
    time_t t = time(nullptr);
    if (t > 1700000000) {
      if (!ntpOK) Serial.println("[NTP] acquired.");
      ntpOK = true;
      if (rtcOK) {
        uint32_t rtcNow = rtc.now().unixtime();
        if (labs((long)rtcNow - (long)t) > 2) {
          rtc.adjust(DateTime((uint32_t)t));
          Serial.println("[RTC] re-sync from NTP.");
        }
      }
    }
    lastNtpCheck = millis();
  }

  /* ==== ส่งขึ้นชีตตามรอบเวลา หรือเมื่อมีเหตุ ==== */
  if (needImmediatePost || (millis() - lastPostMs >= POST_INTERVAL_MS)) {
    needImmediatePost = false;
    lastPostMs = millis();
    postToGoogleSheet();
  }
}

/* ==== Cloud callbacks ==== */
void onMsgCommandChange(){
  if (g_echoing) { Serial.println("[CB] echo skip"); return; }
  String raw = msgCommand;
  Serial.println(String("[CB] onMsgCommandChange raw='")+raw+"' len="+raw.length());

  String all = normalizeSpaces(raw); if (all.length()==0){ showSuggestions('?'); return; }
  String u = toUpperAscii(all); if (u=="HELP" || u=="?"){ showSuggestions('?'); return; }

  int start=0; bool anyOK=false;
  while (start < (int)all.length()){
    int comma = all.indexOf(',', start);
    String part = (comma>=0)? all.substring(start, comma) : all.substring(start);
    part.trim(); start = (comma>=0)? comma+1 : all.length(); if (part.length()==0) continue;

    String who, act, tail; split3Tokens(part, who, act, tail);

    if (act.length()==0 || act=="?" || act=="？"){
      if (isAny(who,"A",nullptr,nullptr)) showSuggestions('A');
      else if (isAny(who,"B",nullptr,nullptr)) showSuggestions('B');
      else if (isAny(who,"ALL","ทั้งหมด",nullptr)) showSuggestions('X');
      else showSuggestions('?'); anyOK=true; continue;
    }

    char which=0;
    if (isAny(who,"A",nullptr,nullptr)) which='A';
    else if (isAny(who,"B",nullptr,nullptr)) which='B';
    else if (isAny(who,"ALL","ทั้งหมด",nullptr)) which='X';
    else { Serial.println("[Msg] Skip (WHO?): "+part); continue; }

    bool isCancel=false, turnOn=false;
    if (isAny(act,"ON","OPEN","เปิด")) turnOn=true;
    else if (isAny(act,"OFF","CLOSE","ปิด")) turnOn=false;
    else if (isAny(act,"CANCEL","ยกเลิก",nullptr)) isCancel=true;
    else { Serial.println("[Msg] Skip (ACTION?): "+part); continue; }

    if (isCancel){ cancelTimers(which?which:'X'); anyOK=true; continue; }

    bool handledAbs=false;
    if (tail.length()>0){
      int _h,_m;
      if (hasAtKeyword(tail) || findHHMM(tail, _h, _m)){
        uint32_t whenUTC = parseLocalHHMM_toUTC(tail);
        if (whenUTC != 0){ scheduleActionAt(which?which:'X', turnOn, whenUTC); anyOK=true; handledAbs=true; }
      }
    }
    if (handledAbs) continue;

    int mins = parseDurationToMinutes(tail);
    scheduleAction(which?which:'X', turnOn, mins); anyOK=true;
  }
  if (!anyOK) showSuggestions('?');
}

void onRelayAChange(){ if (relayA) latchedA=false; digitalWrite(RELAY_A_PIN, relayA?RELAY_ON:RELAY_OFF); }
void onRelayBChange(){ if (relayB) latchedB=false; digitalWrite(RELAY_B_PIN, relayB?RELAY_ON:RELAY_OFF); }
void onResetEnergyChange(){ if (resetEnergy){ energyWh=0.0f; resetEnergy=false; Serial.println("[Cloud] Energy reset."); } }

/* ==== ส่งขึ้นชีต (GET) ==== */
void postToGoogleSheet(){
  WiFiClientSecure client; client.setInsecure();
  HTTPClient https;
  https.setTimeout(8000);
  https.setFollowRedirects(HTTPC_FORCE_FOLLOW_REDIRECTS);

  String url = String(SCRIPT_URL) + "?k=" + SHEET_SECRET
    + "&swA=" + (relayA ? "true":"false")
    + "&swB=" + (relayB ? "true":"false")
    + "&iIn=" + String(currentAll,3)
    + "&vIn=" + String(voltageAll,1)
    + "&vA="  + String(voltageA,1)
    + "&vB="  + String(voltageB,1)
    + "&iA="  + String(currentA,3)
    + "&iB="  + String(currentB,3)
    + "&pA="  + String(powerA,2)
    + "&pB="  + String(powerB,2)
    + "&tC="  + String(tempC,1)
    + "&hum=" + String(humidity,1)
    + "&tripA=" + (tripA_flag ? "true":"false")
    + "&tripB=" + (tripB_flag ? "true":"false");

  if (!https.begin(client, url)) { Serial.println("[Sheet] begin() failed"); return; }
  int code = https.GET();
  String resp = https.getString();
  https.end();
  Serial.printf("[Sheet] GET %d: %s\n", code, resp.c_str());

  tripA_flag = false; tripB_flag = false;
}

อันนี้เป็นโค้ดส่วนแรกที่ฉันทำไว้ ยังติดปัญหาเกี่ยวกับกระแส เวลาโหลดไม่สูงจะไม่ขึ้น พอเสียบที่โหลดสูงค่าที่ได้น้อยเกินไป แต่ฉันทำโค้ดกระแสมาเฉพาะแล้ว

--------------------------------------------------------------------------------------------------------
serial monitor
Araw=0.159 baseA=0.074 actA=1 | Brow=0.115 baseB=0.075 actB=1 | IA=0.081 IB=0.040 | PUB=0.08,0.05,0.13
Araw=0.158 baseA=0.074 actA=1 | Brow=6.857 baseB=0.075 actB=1 | IA=0.084 IB=6.772 | PUB=0.08,1.73,1.81
Araw=0.159 baseA=0.074 actA=1 | Brow=6.773 baseB=0.075 actB=1 | IA=0.085 IB=6.688 | PUB=0.08,2.97,3.05
Araw=0.161 baseA=0.074 actA=1 | Brow=6.899 baseB=0.075 actB=1 | IA=0.086 IB=6.814 | PUB=0.08,3.93,4.01
Araw=0.145 baseA=0.074 actA=1 | Brow=6.865 baseB=0.075 actB=1 | IA=0.071 IB=6.780 | PUB=0.08,4.64,4.72
Araw=0.177 baseA=0.074 actA=1 | Brow=6.765 baseB=0.075 actB=1 | IA=0.103 IB=6.680 | PUB=0.09,5.15,5.24
Araw=0.144 baseA=0.074 actA=1 | Brow=6.879 baseB=0.075 actB=1 | IA=0.070 IB=6.794 | PUB=0.08,5.56,5.64
Araw=0.152 baseA=0.074 actA=1 | Brow=6.842 baseB=0.075 actB=1 | IA=0.078 IB=6.757 | PUB=0.08,5.86,5.94
Araw=0.143 baseA=0.074 actA=1 | Brow=6.749 baseB=0.075 actB=1 | IA=0.069 IB=6.664 | PUB=0.08,6.06,6.14
Araw=0.176 baseA=0.074 actA=1 | Brow=6.876 baseB=0.075 actB=1 | IA=0.102 IB=6.791 | PUB=0.08,6.24,6.33
Araw=0.186 baseA=0.074 actA=1 | Brow=6.790 baseB=0.075 actB=1 | IA=0.111 IB=6.705 | PUB=0.09,6.36,6.45
Araw=0.173 baseA=0.074 actA=1 | Brow=6.819 baseB=0.075 actB=1 | IA=0.098 IB=6.734 | PUB=0.09,6.45,6.55
Araw=0.137 baseA=0.074 actA=1 | Brow=6.863 baseB=0.075 actB=1 | IA=0.063 IB=6.778 | PUB=0.09,6.53,6.62
Araw=0.152 baseA=0.074 actA=1 | Brow=6.733 baseB=0.075 actB=1 | IA=0.077 IB=6.648 | PUB=0.08,6.56,6.65
Araw=0.159 baseA=0.074 actA=1 | Brow=6.852 baseB=0.075 actB=1 | IA=0.085 IB=6.767 | PUB=0.08,6.61,6.70
Araw=0.165 baseA=0.074 actA=1 | Brow=6.839 baseB=0.075 actB=1 | IA=0.090 IB=6.754 | PUB=0.09,6.65,6.73

code

/* Smart Plug – Stable current v3.8.3
   - AutoBaseBoot: เซ็ต base จาก raw อัตโนมัติเมื่อบูตแล้วค่าต่ำ
   - Fast on-relay idle capture (เรียน base เร็วขึ้น)
   - raw-idle gate + unclamp คงเดิม
   - bi-AutoK + simultaneous solve คงเดิม
*/
#include "thingProperties.h"
#include <Arduino.h>
#include <math.h>

/*** Pins / Board ***/
#ifndef SWAP_AB
#define SWAP_AB 0
#endif
#define PIN_A2 A3
#define PIN_A3 A2
#if SWAP_AB
  #define ADC_I_A PIN_A3
  #define ADC_I_B PIN_A2
#else
  #define ADC_I_A PIN_A2
  #define ADC_I_B PIN_A3
#endif
#define ADC_I_ALL A6

#ifndef D2
#define D2 2
#endif
#ifndef D5
#define D5 5
#endif
#define RELAY_A_PIN D2
#define RELAY_B_PIN D5
const bool RELAY_ACTIVE_LOW=false;

/*** Options ***/
#define RELAY_GATING true
enum AllMode{ MODE_SUM=0, MODE_CT=1 }; AllMode allMode=MODE_SUM;

/*** ADC & scales ***/
static const float ADC_REF=3.30f; static const int ADC_MAX=4095;
#define ACS712_V_PER_A 0.024f
static const float V_PER_A_A   = ACS712_V_PER_A;
static const float V_PER_A_B   = ACS712_V_PER_A;
static const float V_PER_A_ALL = 0.033f;

/*** Filters & thresholds ***/
static const float EMA_ALPHA_OUT=0.25f, HPF_ALPHA=0.01f;
static const float DZ_A=0.010f, DZ_B=0.012f, DZ_CT=0.020f;
static const float DZ_AFTER_COMP=0.018f;
#define NO_LOAD_THRESHOLD 0.012f

// adaptive raw-idle margin (raw < base + margin → idle)
#define RAW_IDLE_MARGIN_A 0.030f
#define RAW_IDLE_MARGIN_B 0.030f

// side-idle clamp uses IA/IB after comp
#define SIDE_IDLE_I     0.045f
#define OTHER_ACTIVE_I  0.18f
#define SIDE_IDLE_HOLD  1500

// activity hysteresis
#define ACTIVATE_I       0.08f
#define RELEASE_I        0.05f
#define ACTIVATE_COUNT   4
#define RELEASE_COUNT    6
#define ACTIVE_HOLD_MS   4000

// fast unclamp
#define RISE_TRIG_I       0.10f
#define RISE_FRAMES       2
#define RAW_RISE_TRIG_A   0.025f
#define RAW_RISE_TRIG_B   0.020f
#define RAW_RISE_FRAMES   2
#define UNCLAMP_HOLD_MS   2500

// on-relay idle capture (เรียน base แม้ ON)
#define CAPTURE_MARGIN_A   0.035f
#define CAPTURE_MARGIN_B   0.035f
#define CAPTURE_HOLD_MS    600       // เร็วขึ้นจาก 1200
#define CAPTURE_ALPHA      0.60f     // ดัน base เข้าหา raw ไวขึ้น

/*** Helpers ***/
static inline float adcToVolt(int a){ return (a*ADC_REF)/(float)ADC_MAX; }
static inline float ema(float p,float x,float a){ return a*x + (1.0f-a)*p; }
static inline float deadzone(float x,float dz){ return (fabsf(x)<dz)?0.0f:x; }
static inline float round2(float x){ return roundf(x*100.0f)/100.0f; }
static inline float floorToZero(float x,float eps=2e-3f){ return (fabsf(x)<eps)?0.0f:x; }

/*** HPF offsets ***/
float offA=ADC_REF/2, offB=ADC_REF/2, offAll=ADC_REF/2;

/*** Irms HPF ***/
static float readIrmsHPF(int pin,float &off,float v_per_A){
  const uint32_t T=120, t0=millis(); double s=0; uint32_t n=0;
  while(millis()-t0<T){
    float v=adcToVolt(analogRead(pin));
    off=ema(off,v,HPF_ALPHA);
    float ac=v-off; s += (double)ac*ac; n++; yield();
  }
  if(!n) return 0.0f;
  float Vrms=sqrt(s/(double)n);
  return Vrms/v_per_A;
}

/*** Cal/Zero & bases ***/
float calA=1.0f, calB=1.0f;
float baseA=0.0f, baseB=0.0f;

static void doZero(){
  double sA=0,sB=0; int n=0; uint32_t t0=millis();
  while(millis()-t0<1200){
    sA+=readIrmsHPF(ADC_I_A,offA,V_PER_A_A)*calA;
    sB+=readIrmsHPF(ADC_I_B,offB,V_PER_A_B)*calB;
    n++; delay(5);
  }
  baseA=constrain((float)(sA/(n?n:1)),0.0f,0.5f);
  baseB=constrain((float)(sB/(n?n:1)),0.0f,0.5f);
  Serial.printf("[Zero] baseA=%.3f baseB=%.3f\n",baseA,baseB);
}

/*** Cross learn (เดิม) ***/
bool  compEnabled=true;
float K_BA=0.40f, K_AB=0.40f;
const float K_ALPHA=0.30f;
static uint32_t kLogMs=0;
static void learnK_BA(float iA,float iB,float A_raw,float B_raw){
  if(relayA && (B_raw<baseB+RAW_IDLE_MARGIN_B) && (iB<0.03f) && iA>0.10f){
    float r=(iA>0.001f)?(iB/iA):0.0f; r=constrain(r,0.0f,0.90f);
    K_BA=ema(K_BA,r,K_ALPHA);
    if(!kLogMs || millis()-kLogMs>3000){ Serial.printf("[AutoK_BA] K_BA=%.3f\n",K_BA); kLogMs=millis(); }
  }
}
static void learnK_AB(float iA,float iB,float A_raw,float B_raw){
  if(relayB && (A_raw<baseA+RAW_IDLE_MARGIN_A) && (iA<0.03f) && iB>0.10f){
    float r=(iB>0.001f)?(iA/iB):0.0f; r=constrain(r,0.0f,0.90f);
    K_AB=ema(K_AB,r,K_ALPHA);
    if(!kLogMs || millis()-kLogMs>3000){ Serial.printf("[AutoK_AB] K_AB=%.3f\n",K_AB); kLogMs=millis(); }
  }
}

/*** States ***/
uint32_t bothIdleTs=0;
int actCntA=0, relCntA=0, actCntB=0, relCntB=0;
bool activeA=false, activeB=false;
uint32_t activeUntilA=0, activeUntilB=0;

// fast-unclamp + drip/idle-capture timers
int riseCntA=0, riseCntB=0, rawRiseCntA=0, rawRiseCntB=0;
uint32_t unclampUntilA=0, unclampUntilB=0;
uint32_t onIdleSinceA=0, onIdleSinceB=0;
uint32_t capSinceA=0, capSinceB=0;

/*** Outputs ***/
float iA_o=0.0f, iB_o=0.0f, iAll_o=0.0f;

void setup(){
  Serial.begin(115200); delay(300);
  pinMode(RELAY_A_PIN,OUTPUT); pinMode(RELAY_B_PIN,OUTPUT);
  bool offLevel=RELAY_ACTIVE_LOW?HIGH:LOW;
  digitalWrite(RELAY_A_PIN,offLevel); digitalWrite(RELAY_B_PIN,offLevel);

  analogReadResolution(12); analogSetAttenuation(ADC_11db);

  initProperties();
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  Serial.println("[INFO] v3.8.3 AutoBaseBoot + fast capture");
}

void loop(){
  ArduinoCloud.update();

  float A_raw=readIrmsHPF(ADC_I_A,offA,V_PER_A_A)*calA;
  float B_raw=readIrmsHPF(ADC_I_B,offB,V_PER_A_B)*calB;
  float CT_raw=readIrmsHPF(ADC_I_ALL,offAll,V_PER_A_ALL);

  baseA=constrain(baseA,0.0f,0.5f);
  baseB=constrain(baseB,0.0f,0.5f);

  // --- AutoBaseBoot (ฉุกเฉิน): bases เป็น 0 และค่าดิบต่ำ → ตั้งฐานทันที ---
  if(baseA<0.005f && baseB<0.005f && A_raw<0.25f && B_raw<0.25f){
    baseA=A_raw; baseB=B_raw;
    Serial.printf("[AutoBaseBoot] baseA=%.3f baseB=%.3f\n",baseA,baseB);
  }

  // pre-comp currents
  float iA=A_raw-baseA; if(iA<0)iA=0; iA=deadzone(iA,DZ_A); if(iA<NO_LOAD_THRESHOLD)iA=0;
  float iB=B_raw-baseB; if(iB<0)iB=0; iB=deadzone(iB,DZ_B); if(iB<NO_LOAD_THRESHOLD)iB=0;
  if(RELAY_GATING){ if(!relayA) iA=0; if(!relayB) iB=0; }

  // raw-idle flags
  bool rawIdleA = (A_raw < baseA + RAW_IDLE_MARGIN_A);
  bool rawIdleB = (B_raw < baseB + RAW_IDLE_MARGIN_B);

  // activity (gate ด้วย rawIdle)
  if(iA>ACTIVATE_I && !rawIdleA){ if(++actCntA>=ACTIVATE_COUNT){ activeA=true; activeUntilA=millis()+ACTIVE_HOLD_MS; relCntA=0; } }
  else if(iA<RELEASE_I || rawIdleA){ if(++relCntA>=RELEASE_COUNT && millis()>activeUntilA){ activeA=false; actCntA=0; } }

  if(iB>ACTIVATE_I && !rawIdleB){ if(++actCntB>=ACTIVATE_COUNT){ activeB=true; activeUntilB=millis()+ACTIVE_HOLD_MS; relCntB=0; } }
  else if(iB<RELEASE_I || rawIdleB){ if(++relCntB>=RELEASE_COUNT && millis()>activeUntilB){ activeB=false; actCntB=0; } }

  // rise detectors
  if(iA>RISE_TRIG_I){ if(++riseCntA>=RISE_FRAMES){ unclampUntilA=millis()+UNCLAMP_HOLD_MS; activeA=true; } }
  else riseCntA=0;
  if(iB>RISE_TRIG_I){ if(++riseCntB>=RISE_FRAMES){ unclampUntilB=millis()+UNCLAMP_HOLD_MS; activeB=true; } }
  else riseCntB=0;

  if((A_raw-baseA)>RAW_RISE_TRIG_A){ if(++rawRiseCntA>=RAW_RISE_FRAMES){ unclampUntilA=millis()+UNCLAMP_HOLD_MS; activeA=true; } }
  else rawRiseCntA=0;
  if((B_raw-baseB)>RAW_RISE_TRIG_B){ if(++rawRiseCntB>=RAW_RISE_FRAMES){ unclampUntilB=millis()+UNCLAMP_HOLD_MS; activeB=true; } }
  else rawRiseCntB=0;

  // learn K
  learnK_BA(iA,iB,A_raw,B_raw);
  learnK_AB(iA,iB,A_raw,B_raw);

  // simultaneous solve
  float eps=1e-6f;
  float kBA_eff=max(0.0f,K_BA-0.05f);
  float kAB_eff=max(0.0f,K_AB-0.05f);
  const float DOM_RATIO=2.0f;
  float rAB=(iB>eps)?(iA/(iB+eps)):999.0f;
  float rBA=(iA>eps)?(iB/(iA+eps)):999.0f;
  if(rAB>DOM_RATIO) kBA_eff=0.0f;
  if(rBA>DOM_RATIO) kAB_eff=0.0f;
  const float CAP_FRAC=0.05f, CAP_ABS=0.01f;
  float maxSubB=min(CAP_FRAC*iB,CAP_ABS); if(iA>eps) kBA_eff=min(kBA_eff, maxSubB/(iA+eps));
  float maxSubA=min(CAP_FRAC*iA,CAP_ABS); if(iB>eps) kAB_eff=min(kAB_eff, maxSubA/(iB+eps));
  float denom=1.0f-kAB_eff*kBA_eff; if(denom<0.70f) denom=0.70f;
  float IA=(iA - kAB_eff*iB)/denom;
  float IB=(iB - kBA_eff*iA)/denom;
  if(IA<0) IA=0; if(IB<0) IB=0;

  // side-idle clamp (adaptive raw)
  bool otherActiveA=(IB>OTHER_ACTIVE_I);
  bool otherActiveB=(IA>OTHER_ACTIVE_I);
  bool allowClampA = !(activeA || (millis()<unclampUntilA));
  bool allowClampB = !(activeB || (millis()<unclampUntilB));
  if(allowClampA && ( !relayA || (rawIdleA && IA<SIDE_IDLE_I && !otherActiveA) )) IA=0.0f;
  if(allowClampB && ( !relayB || (rawIdleB && IB<SIDE_IDLE_I && !otherActiveB) )) IB=0.0f;

  if(IA<DZ_AFTER_COMP) IA=0.0f;
  if(IB<DZ_AFTER_COMP) IB=0.0f;

  // Fast on-relay capture: ดัน base เข้า raw เมื่อสงบ
  if(relayA && rawIdleA && IA < CAPTURE_MARGIN_A){
    if(!capSinceA) capSinceA=millis();
    if(millis()-capSinceA>CAPTURE_HOLD_MS){
      baseA = constrain((1.0f-CAPTURE_ALPHA)*baseA + CAPTURE_ALPHA*A_raw, 0.0f, 0.5f);
    }
  } else capSinceA=0;

  if(relayB && rawIdleB && IB < CAPTURE_MARGIN_B){
    if(!capSinceB) capSinceB=millis();
    if(millis()-capSinceB>CAPTURE_HOLD_MS){
      baseB = constrain((1.0f-CAPTURE_ALPHA)*baseB + CAPTURE_ALPHA*B_raw, 0.0f, 0.5f);
    }
  } else capSinceB=0;

  // publish
  float iAll=(allMode==MODE_SUM)?(IA+IB):deadzone(CT_raw,DZ_CT);
  iA_o=ema(iA_o,IA,EMA_ALPHA_OUT);
  iB_o=ema(iB_o,IB,EMA_ALPHA_OUT);
  iAll_o=ema(iAll_o,iAll,EMA_ALPHA_OUT);

  currentA=round2(floorToZero(iA_o));
  currentB=round2(floorToZero(iB_o));
  currentAll=round2(floorToZero(iAll_o));

  Serial.printf("Araw=%.3f baseA=%.3f actA=%d | Brow=%.3f baseB=%.3f actB=%d | IA=%.3f IB=%.3f | PUB=%.2f,%.2f,%.2f\n",
                A_raw,baseA,(int)activeA, B_raw,baseB,(int)activeB, IA,IB,
                currentA,currentB,currentAll);

  delay(300);
}

/*** Cloud ***/
void onMsgCommandChange(){
  if(!msgCommand.length()) return;
  String s=msgCommand; s.trim(); s.toUpperCase();
  if(s=="ZERO"){ doZero(); }
  if(s=="FORCE ZERO"){ // ตั้งฐานจาก raw ทันที
    // อ่านครั้งสั้น ๆ เพื่อกัน noise
    baseA=readIrmsHPF(ADC_I_A,offA,V_PER_A_A)*calA;
    baseB=readIrmsHPF(ADC_I_B,offB,V_PER_A_B)*calB;
    Serial.printf("[ForceZero] baseA=%.3f baseB=%.3f\n",baseA,baseB);
  }
  if(s=="MODE SUM"){ allMode=MODE_SUM; }
  if(s=="MODE CT"){  allMode=MODE_CT;  }
  if(s=="COMP ON"){  compEnabled=true; }
  if(s=="COMP OFF"){ compEnabled=false; }
  if(s.startsWith("CAL A =")){
    float t=s.substring(8).toFloat();
    float m=readIrmsHPF(ADC_I_A,offA,V_PER_A_A);
    if(m>0.0005f){ calA=t/m; Serial.printf("[Cal] calA=%.4f\n",calA); }
  }
  if(s.startsWith("CAL B =")){
    float t=s.substring(8).toFloat();
    float m=readIrmsHPF(ADC_I_B,offB,V_PER_A_B);
    if(m>0.0005f){ calB=t/m; Serial.printf("[Cal] calB=%.4f\n",calB); }
  }
  if(s.indexOf("A ON")>=0){ relayA=true;  onRelayAChange(); }
  if(s.indexOf("A OFF")>=0){ relayA=false; onRelayAChange(); }
  if(s.indexOf("B ON")>=0){ relayB=true;  onRelayBChange(); }
  if(s.indexOf("B OFF")>=0){ relayB=false; onRelayBChange(); }
}

void onRelayAChange(){
  bool level=RELAY_ACTIVE_LOW? !relayA:relayA;
  digitalWrite(RELAY_A_PIN, level?HIGH:LOW);
  if(!relayA && RELAY_GATING){ currentA=iA_o=0.0f; activeA=false; }
  Serial.printf("[Cloud] Relay A -> %s\n", relayA? "ON":"OFF");
}
void onRelayBChange(){
  bool level=RELAY_ACTIVE_LOW? !relayB:relayB;
  digitalWrite(RELAY_B_PIN, level?HIGH:LOW);
  if(!relayB && RELAY_GATING){ currentB=iB_o=0.0f; activeB=false; }
  Serial.printf("[Cloud] Relay B -> %s\n", relayB? "ON":"OFF");
}
void onResetEnergyChange(){
  if(resetEnergy){ resetEnergy=false; Serial.println("[Cloud] Energy reset."); }
}

อันนี้คือส่วนที่2 กระแสตรงกับที่ฉันต้องการ

คำสั่งคือฉันอยากนำ code ส่วนที่2 มาแทนในส่วนแรก เพราะกระแสในโค้ดส่วนแรกไม่ใช่สิ่งที่ฉันต้องการ ทำให้ได่ไหม 
หมายเหตุ 
